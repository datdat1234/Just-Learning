# Static Initialization

- In Chapter 1, we covered instance initializers that looked like unnamed methods. Just code inside braces. Static initializers look similar. They add the static keyword to specify they should be run when the class is first used. For example:

```
private static final int NUM_SECONDS_PER_HOUR;
static {
 int numSecondsPerMinute = 60;
 int numMinutesPerHour = 60;
 NUM_SECONDS_PER_HOUR = numSecondsPerMinute * numMinutesPerHour;
}
```

- The static initializer runs when the class is first used. The statements in it run and assign any static variables as needed. There is something interesting about this example. We just got through saying that final variables aren’t allowed to be reassigned. The key here is that the static initializer is the first assignment. And since it occurs up front, it is okay.

```
14: private static int one;
15: private static final int two;
16: private static final int three = 3;
17: private static final int four; // DOES NOT COMPILE
18: static {
19:  one = 1;
20:  two = 2;
21:  three = 3; // DOES NOT COMPILE
22:  two = 4; // DOES NOT COMPILE
23: }
```

- Line 14 declares a static variable that is not final. It can be assigned as many times as we like. Line 15 declares a final variable without initializing it. This means we can initialize it exactly once in a static block. Line 22 doesn’t compile because this is the second attempt. Line 16 declares a final variable and initializes it at the same time. We are not allowed to assign it again, so line 21 doesn’t compile. Line 17 declares a final variable that never gets initialized. The compiler gives a compiler error because it knows that the static blocks are the only place the variable could possibly get initialized. Since the programmer forgot, this is clearly an error.

- __Try to Avoid Static and Instance Initializers__: Using static and instance initializers can make your code much harder to read. Everything that could be done in an instance initializer could be done in a constructor instead. The constructor approach is easier to read. There is a common case to use a static initializer: when you need to initialize a static field and the code to do so requires more than one line. This often occurs when you want to initialize a collection like an ArrayList. When you do need to use a static initializer, put all the static initialization in the same block. That way, the order is obvious.

# Static Imports

- Back in Chapter 1, you saw that we could import a specific class or all the classes in a package:

```
import java.util.ArrayList;
import java.util.*;
```

- We could use this technique to import:

```
import java.util.List;
import java.util.Arrays;
public class Imports {
 public static void main(String[] args) {
  List<String> list = Arrays.asList("one", "two");
 }
} 
```

- Imports are convenient because you don’t need to specify where each class comes from each time you use it. There is another type of import called a static import. Regular imports are for importing classes. Static imports are for importing static members of classes. Just like regular imports, you can use a wildcard or import a specific member. The idea is that you shouldn’t have to specify where each static method or variable comes from each time you use it. An example of when static interfaces shine are when you are referring to a lot of constants in another class.

- In a large program, static imports can be overused. When importing from too many places, it can be hard to remember where each static member comes from.

- The previous method has one static method call: Arrays.asList. Rewriting the code to use a static import yields the following:

```
import java.util.List;
import static java.util.Arrays.asList; // static import
public class StaticImports {
 public static void main(String[] args) {
  List<String> list = asList("one", "two"); // no Arrays.
 } }
```

- In this example, we are specifically importing the asList method. This means that any time we refer to asList in the class, it will call Arrays.asList(). An interesting case is what would happen if we created an asList method in our StaticImports class. Java would give it preference over the imported one and the method we coded would be used.

```
1: import static java.util.Arrays; // DOES NOT COMPILE
2: import static java.util.Arrays.asList;
3: static import java.util.Arrays.*; // DOES NOT COMPILE
4: public class BadStaticImports {
5:  public static void main(String[] args) {
6:   Arrays.asList("one"); // DOES NOT COMPILE
7: } }
```

- Line 1 tries to use a static import to import a class. Remember that static imports are only for importing static members. Regular imports are for importing a class. Line 3 tries to see if you are paying attention to the order of keywords. The syntax is import static and not vice versa. Line 6 is sneaky. We imported the asList method on line 2. However, we did not import the Arrays class anywhere. This makes it okay to write asList("one"); but not Arrays.asList("one");.

- There’s only one more scenario with static imports. In Chapter 1, you learned that importing two classes with the same name gives a compiler error. This is true of static imports as well. The compiler will complain if you try to explicitly do a static import of two methods with the same name or two static variables with the same name. For example:

```
import static statics.A.TYPE;
import static statics.B.TYPE; // DOES NOT COMPILE
```

- Luckily when this happens, we can just refer to the static members via their classname in the code instead of trying to use a static import.