# Encapsulating Data

- In Chapter 1, we had an example of a class with a field that wasn’t private:

```
public class Swan {
 int numberEggs; // instance variable
}
```

- Why do we care? Since there is default (package private) access, that means any class in the package can set numberEggs. We no longer have control of what gets set in our own class. A caller could even write this:

```
mother.numberEggs = -1; 
```

- This is clearly no good. We do not want the mother Swan to have a negative number of eggs! Encapsulation to the rescue. Encapsulation means we set up the class so only methods in the class with the variables can refer to the instance variables. Callers are required to use these methods. Let’s take a look at our newly encapsulated Swan class:

```
1: public class Swan {
2:  private int numberEggs; // private
3:  public int getNumberEggs() { // getter
4:   return numberEggs;
5:  }
6:  public void setNumberEggs(int numberEggs) { // setter
7:   if (numberEggs >= 0) // guard condition
8:    this.numberEggs = numberEggs;
9:  } }
```

- Note numberEggs is now private on line 2. This means only code within the class can read or write the value of numberEggs. Since we wrote the class, we know better than to set a negative number of eggs. We added a method on lines 3–5 to read the value, which is called an accessor method or a getter. We also added a method on lines 6–9 to update the value, which is called a mutator method or a setter. The setter has an if statement in this example to prevent setting the instance variable to an invalid value. This guard condition protects the instance variable.

- On line 8, we used the this keyword that we saw in constructors to differentiate between the method parameter numberEggs and the instance variable numberEggs.

- For encapsulation, remember that data (an instance variable) is private and getters/setters are public. Java defines a naming convention that is used in JavaBeans. JavaBeans are reusable software components. JavaBeans call an instance variable a property. The only thing you need to know about JavaBeans for the exam is the naming conventions listed in Table below.

| Rule                                                                 | Example                                          |
|----------------------------------------------------------------------|--------------------------------------------------|
| Properties are private.                                             | `private int numEggs;`                          |
| Getter methods begin with `is` if the property is a boolean.       | `public boolean isHappy() { return happy; }`    |
| Getter methods begin with `get` if the property is not a boolean.  | `public int getNumEggs() { return numEggs; }`  |
| Setter methods begin with `set`.                                    | `public void setHappy(boolean happy) { this.happy = happy; }` |
| Method name must have a prefix of `set/get/is`, followed by the first letter of the property in uppercase, followed by the rest of the property name. | `public void setNumEggs(int num) { numEggs = num; }` |

- From the last example in Table above, you noticed that you can name the method parameter to set anything you want. Only the method name and property name have naming conventions here.

- It’s time for some practice. See if you can figure out which lines follow JavaBeans naming conventions:

```
12: private boolean playing;
13: private String name;
14: public boolean getPlaying() { return playing; }
15: public boolean isPlaying() { return playing; }
16: public String name() { return name; }
17: public void updateName(String n) { name = n; }
18: public void setname(String n) { name = n; }
```

- Lines 12 and 13 are good. They are private instance variables. Line 14 doesn't follow the JavaBeans naming conventions. Since playing is a boolean, the getter must begin with is. Line 15 is a correct getter for playing. Line 16 doesn't follow the JavaBeans naming conventions because it should be called getName. Lines 17 and 18 do not follow the JavaBeans naming conventions because they should be named setName. Remember that Java is case sensitive, so setname is not adequate to meet the naming convention.

## Creating Immutable Classes

- Encapsulating data is helpful because it prevents callers from making uncontrolled changes to your class. Another common technique is making classes immutable so they cannot be changed at all.

-  Immutable classes are helpful because you know they will always be the same. You can pass them around your application with a guarantee that the caller didn’t change anything. This helps make programs easier to maintain. It also helps with performance by limiting the number of copies, as you saw with String in Chapter 3, “Core Java APIs.”

- One step in making a class immutable is to omit the setters. But wait: we still want the caller to be able to specify the initial value—we just don’t want it to change after the object is created. Constructors to the rescue!

```
public class ImmutableSwan {
 private int numberEggs;
 public ImmutableSwan(int numberEggs) {
  this.numberEggs = numberEggs;
 }
 public int getNumberEggs() {
  return numberEggs;
 } }
```

- In this example, we don't have a setter. We do have a constructor that allows a value to be set. Remember, immutable is only measured after the object is constructed. Immutable classes are allowed to have values. They just can't change after instantiation.

- __Return Types in Immutable Classes__: When you are writing an immutable class, be careful about the return types. On the surface, this class appears to be immutable since there is no setter:

```
public class NotImmutable {
 private StringBuilder builder;
 public NotImmutable(StringBuilder b) {
  builder = b;
 }
 public StringBuilder getBuilder() {
  return builder;
 } }
```

```
StringBuilder sb = new StringBuilder("initial");
NotImmutable problem = new NotImmutable(sb);
sb.append(" added");
StringBuilder gotBuilder = problem.getBuilder();
gotBuilder.append(" more");
System.out.println(problem.getBuilder());
```

- This outputs "initial added more"—clearly not what we were intending. The problem is that we are just passing the same StringBuilder all over. The caller has a reference since it was passed to the constructor. Anyone who calls the getter gets a reference too. A solution is to make a copy of the mutable object. This is called a defensive copy.

```
public Mutable(StringBuilder b) {
 builder = new StringBuilder(b);
}
public StringBuilder getBuilder() {
 return new StringBuilder(builder);
}
```

- Now the caller can make changes to the initial sb object and it is fine. Mutable no longer cares about that object after the constructor gets run. The same goes for the getter: callers can change their StringBuilder without affecting Mutable.

- Another approach for the getter is to return an immutable object:

```
public String getValue() {
 return builder.toString();
}
```

- There’s no rule that says we have to return the same type as we are storing. String is safe to return because it is immutable in the first place.

- To review, encapsulation refers to preventing callers from changing the instance variables directly. Immutability refers to preventing callers from changing the instance variables at all.