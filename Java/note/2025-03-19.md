## Polymorphic Parameters

- One of the most useful applications of polymorphism is the ability to pass instances of a subclass or interface to a method. For example, you can defi ne a method that takes an instance of an interface as a parameter. In this manner, any class that implements the interface can be passed to the method. Since you’re casting from a subtype to a supertype, an explicit cast is not required. This property is referred to as polymorphic parameters of a method, and we demonstrate it in the following example:


```java
public class Reptile {
 public String getName() {
  return "Reptile";
 }
}
public class Alligator extends Reptile {
 public String getName() {
  return "Alligator";
 }
}
public class Crocodile extends Reptile {
 public String getName() {
  return "Crocodile";
 }
}
public class ZooWorker {
 public static void feed(Reptile reptile) {
  System.out.println("Feeding reptile "+reptile.getName());
 }
 public static void main(String[] args) {
  feed(new Alligator());
  feed(new Crocodile());
  feed(new Reptile());
 }
}
```

- This code compiles and executes without issue, yielding the following output:

```
Feeding: Alligator
Feeding: Crocodile
Feeding: Reptile
```

- Let’s focus on the feed(Reptile reptile) method in this example. As you can see, that method was able to handle instances of Alligator and Crocodile without issue, because both are subclasses of the Reptile class. It was also able to accept a matching type Reptile class. If we had tried to pass an unrelated class, such as the previously defi ned Rodent or Capybara classes, or a superclass such as java.lang.Object, to the feed() method, the code would not have compiled.

- __Polymorphic Parameters and Code Reusability__: If you’re defi ning a method that will be accessible outside the current class, either to subclasses of the current class or publicly to objects outside the current class, it is considered good coding practice to use the superclass or interface type of input parameters whenever possible.

- As you may remember from Chapter 3, “Core Java APIs,” the type java.util.List is an interface, not a class. Although there are many classes that implement java.util.List, such as java.util.ArrayList and java.util.Vector, when you’re passing an existing List you’re not usually interested in the particular subclass of the List. In this manner, a method that passes a List should use the interface type java.util.List as the polymorphic parameter type, rather than a specifi c class that implements List, as the code will be more reusable for other types of lists.

- For example, it is common to see code such as the following that uses the interface reference type over the class type for greater reusability:

```java
java.util.List list = new java.util.ArrayList();
```

## Polymorphism and Method Overriding

- Let’s conclude this chapter by returning to the last three rules for method overriding to demonstrate how polymorphism requires them to be included as part of the Java specifi cation. You’ll see that without such rules in place, it is easy to construct an example with polymorphism in Java.

- The fi rst rule is that an overridden method must be at least as accessible as the method it is overriding. Let’s assume this rule is not necessary and consider the following example:

```java
public class Animal {
 public String getName() {
  return "Animal";
 }
}
public class Gorilla extends Animal {
 protected String getName() { // DOES NOT COMPILE
  return "Gorilla";
 }
}
public class ZooKeeper {
 public static void main(String[] args) {
  Animal animal = new Gorilla();
  System.out.println(animal.getName());
 }
}
```

- For the purpose of this discussion, we’ll ignore the fact that the implementation of getName() in the Gorilla class doesn’t compile because it is less accessible than the version it is overriding in the Animal class.

- As you can see, this example creates an ambiguity problem in the ZooKeeper class. The reference animal.getName() is allowed because the method is public in the Animal class, but due to polymorphism, the Gorilla object itself has been overridden with a less accessible version, not available to the ZooKeeper class. This creates a contradiction in that the compiler should not allow access to this method, but because it is being referenced as an instance of Animal, it is allowed. Therefore, Java eliminates this contradiction, thus disallowing a method from being overridden by a less accessible version of the method.

- Likewise, a subclass cannot declare an overridden method with a new or broader exception than in the superclass, since the method may be accessed using a reference to the superclass. For example, if an instance of the subclass is passed to a method using a superclass reference, then the enclosing method would not know about any new checked exceptions that exist on methods for this object, potentially leading to compiled code with “unchecked” checked exceptions. Therefore, the Java compiler disallows overriding methods with new or broader exceptions.

- Finally, overridden methods must use covariant return types for the same kinds of reasons as just discussed. If an object is cast to a superclass reference and the overridden method is called, the return type must be compatible with the return type of the parent method. If the return type in the child is too broad, it will result an inherent cast exception when accessed through the superclass reference.

- For example, if the return type of a method is Double in the parent class and is overridden in a subclass with a method that returns Number, a superclass of Double, then the subclass method would be allowed to return any valid Number, including Integer, another subclass of Number. If we are using the object with a reference to the superclass, that means an Integer could be returned when a Double was expected. Since Integer is not a subclass of Double, this would lead to an implicit cast exception as soon as the value was referenced. Java solves this problem by only allowing covariant return types for overridden methods.

# Summary

- This chapter took the basic class structure we presented in Chapter 4 and expanded it by introducing the notion of inheritance. Java classes follow a multilevel single-inheritance pattern in which every class has exactly one direct parent class, with all classes eventually inheriting from java.lang.Object. Java interfaces simulate a limited form of multiple inheritance, since Java classes may implement multiple interfaces.

- Inheriting a class gives you access to all of the public and protected methods of the class, but special rules for constructors and overriding methods must be followed or the code will not compile. For example, if the parent class doesn’t include a no-argument constructor, an explicit call to a parent constructor must be provided in the child’s constructors. Pay close attention on the exam to any class that defi nes a constructor with arguments and doesn’t defi ne a no-argument constructor.

- We reviewed overloaded, overridden, and hidden methods and showed how they differ, especially in terms of polymorphism. We also introduced the notion of hiding variables, although we strongly discourage this in practice as it often leads to confusing, diffi cult-tomaintain code.

- We introduced abstract classes and interfaces and showed how you can use them to defi ne a platform for other developers to interact with. By defi nition, an abstract type cannot be instantiated directly and requires a concrete subclass for the code to be used. Since default and static interface methods are new to Java 8, expect to see at least one question on them on the exam.

- Finally, this chapter introduced the concept of polymorphism, central to the Java language, and showed how objects can be accessed in a variety of forms. Make sure you understand when casts are needed for accessing objects, and be able to spot the difference between compile-time and runtime cast problems.

# Exam Essentials

- __Be able to write code that extends other classes.__ A Java class that extends another class inherits all of its public and protected methods and variables. The fi rst line of every constructor is a call to another constructor within the class using this() or a call to a constructor of the parent class using the super() call. If the parent class doesn’t contain a noargument constructor, an explicit call to the parent constructor must be provided. Parent methods and objects can be accessed explicitly using the super keyword. Finally, all classes in Java extend java.lang.Object either directly or from a superclass.

- __Understand the rules for method overriding.__ The Java compiler allows methods to be overridden in subclasses if certain rules are followed: a method must have the same signature, be at least as accessible as the parent method, must not declare any new or broader exceptions, and must use covariant return types. 

- __Understand the rules for hiding methods and variables.__ When a static method is recreated in a subclass, it is referred to as method hiding. Likewise, variable hiding is when a variable name is reused in a subclass. In both situations, the original method or variable still exists and is used in methods that reference the object in the parent class. For method hiding, the use of static in the method declaration must be the same between the parent and child class. Finally, variable and method hiding should generally be avoided since it leads to confusing and diffi cult-to-follow code.

- __Recognize the difference between method overriding and method overloading.__ Both method overloading and overriding involve creating a new method with the same name as an existing method. When the method signature is the same, it is referred to as method overriding and must follow a specifi c set of override rules to compile. When the method signature is different, with the method taking different inputs, it is referred to as method overloading and none of the override rules are required.

- __Be able to write code that creates and extends abstract classes.__ In Java, classes and methods can be declared as abstract. Abstract classes cannot be instantiated and require a concrete subclass to be accessed. Abstract classes can include any number, including zero, of abstract and nonabstract methods. Abstract methods follow all the method override rules and may only be defi ned within abstract classes. The fi rst concrete subclass of an abstract class must implement all the inherited methods. Abstract classes and methods may not be marked as final or private.

- __Be able to write code that creates, extends, and implements interfaces.__ Interfaces are similar to a specialized abstract class in which only abstract methods and constant static final variables are allowed. New to Java 8, an interface can also define default and static methods with method bodies. All members of an interface are assumed to be public. Methods are assumed to be abstract if not explicitly marked as default or static. An interface that extends another interface inherits all its abstract methods. An interface cannot extend a class, nor can a class extend an interface. Finally, classes may implement any number of interfaces.

- __Be able to write code that uses default and static interface methods.__ A default method allows a developer to add a new method to an interface used in existing implementations, without forcing other developers using the interface to recompile their code. A developer using the interface may override the default method or use the provided one. A static method in an interface follows the same rules for a static method in a class.

- __Understand polymorphism.__ An object in Java may take on a variety of forms, in part depending on the reference used to access the object. Methods that are overridden will be replaced everywhere they are used, whereas methods and variables that are hidden will only be replaced in the classes and subclasses that they are defi ned. It is common to rely on polymorphic parameters—the ability of methods to be automatically passed as a superclass or interface reference—when creating method defi nitions.

- __Recognize valid reference casting.__ An instance can be automatically cast to a superclass or interface reference without an explicit cast. Alternatively, an explicit cast is required if the reference is being narrowed to a subclass of the object. The Java compiler doesn’t permit casting to unrelated types. You should be able to discern between compiler-time casting errors and those that will not occur until runtime and that throw a CastClassException.