## Predicates

- In our earlier example, we created an interface with one method:

```
boolean test(Animal a);
```

- Lambdas work with interfaces that have only one method. These are called functional interfaces—interfaces that can be used with functional programming. (It’s actually more complicated than this, but for the OCA exam this definition is fine.)

- You can imagine that we’d have to create lots of interfaces like this to use lambdas. We want to test Animals and Strings and Plants and anything else that we come across.

- Luckily, Java recognizes that this is a common problem and provides such an interface for us. It’s in the package java.util.function and the gist of it is as follows:

```
public interface Predicate<T> {
 boolean test(T t);
}
```

- That looks a lot like our method. The only difference is that it uses this type T instead of Animal. That’s the syntax for generics. It’s like when we created an ArrayList and got to specify any type that goes in it.

- This means we don’t need our own interface anymore and can put everything related to our search in one class:

```
1: import java.util.*;
2: import java.util.function.*;
3: public class PredicateSearch {
4:  public static void main(String[] args) {
5:   List<Animal> animals = new ArrayList<Animal>();
6:   animals.add(new Animal("fish", false, true));
7:
8:   print(animals, a -> a.canHop());
9:  }
10:  private static void print(List<Animal> animals, Predicate<Animal>↵
checker) {
11:   for (Animal animal : animals) {
12:    if (checker.test(animal))
13:     System.out.print(animal + " ");
14:    }
15:    System.out.println();
16:   }
17: }
```

- This time, line 10 is the only one that changed. We expect to have a Predicate passed in that uses type Animal. Pretty cool. We can just use it without having to write extra code.

- Java 8 even integrated the Predicate interface into some existing classes. There is only one you need to know for the exam. ArrayList declares a removeIf() method that takes a Predicate. Imagine we have a list of names for pet bunnies. We decide we want to remove all of the bunny names that don’t begin with the letter h because our little cousin really wants us to choose an H name. We could solve this problem by writing a loop. Or we could solve it in one line:

```
3: List<String> bunnies = new ArrayList<>();
4: bunnies.add("long ear");
5: bunnies.add("floppy");
6: bunnies.add("hoppy");
7: System.out.println(bunnies); // [long ear, floppy, hoppy]
8: bunnies.removeIf(s -> s.charAt(0) != 'h');
9: System.out.println(bunnies); // [hoppy]
```

- Line 8 takes care of everything for us. It defines a predicate that takes a String and returns a boolean. The removeIf() method does the rest.

- For the OCA exam, you only need to know how to implement lambda expressions that use the Predicate interface. Remember the one method in the interface called test()? It takes any one reference type parameter and returns a boolean. Functional programming is a large topic and just the basics are covered. On the OCP exam, you’ll learn how to get rid of the loop entirely for more than just removeIf(). You’ll also learn the rules for implementing your own functional interfaces as we did with CheckTrait.

# Summary

- As you learned in this chapter, Java methods start with an access modifier of public, private, protected or blank (default access). This is followed by an optional specifier such as static, final, or abstract. Next comes the return type, which is void or a Java type. The method name follows, using standard Java identifier rules. Zero or more parameters go in parentheses as the parameter list. Next come any optional exception types. Finally, zero or more statements go in braces to make up the method body.

- Using the private keyword means the code is only available from within the same class. Default (package private) access means the code is only available from within the same package. Using the protected keyword means the code is available from the same package or subclasses. Using the public keyword means the code is available from anywhere. Static methods and static variables are shared by the class. When referenced from outside the class, they are called using the classname—for example, StaticClass.method(). Instance members are allowed to call static members, but static members are not allowed to call instance members. Static imports are used to import static members.

- Java uses pass-by-value, which means that calls to methods create a copy of the parameters. Assigning new values to those parameters in the method doesn’t affect the caller’s variables. Calling methods on objects that are method parameters changes the state of those objects and is reflected in the caller.

- Overloaded methods are methods with the same name but a different parameter list. Java calls the most specific method it can find. Exact matches are preferred, followed by wider primitives. After that comes autoboxing and finally varargs.

- Constructors are used to instantiate new objects. The default no-argument constructor is called when no constructor is coded. Multiple constructors are allowed and can call each other by writing this(). If this() is present, it must be the fi rst statement in the constructor. Constructors can refer to instance variables by writing this before a variable name to indicate they want the instance variable and not the method parameter with that name. The order of initialization is the superclass (which we will cover in Chapter 5); static variables and static initializers in the order they appear; instance variables and instance initializers in the order they appear; and finally the constructor.

- Encapsulation refers to preventing callers from changing the instance variables directly. This is done by making instance variables private and getters/setters public. Immutability refers to preventing callers from changing the instance variables at all. This uses several techniques, including removing setters. JavaBeans use methods beginning with is and get for boolean and non-boolean property types, respectively. Methods beginning with set are used for setters.

- Lambda expressions, or lambdas, allow passing around blocks of code. The full syntax looks like (String a, String b) -> { return a.equals(b); }. The parameter types can be omitted. When only one parameter is specified without a type, the parentheses can also be omitted. The braces and return statement can be omitted for a single statement, making the short form (a -> a.equals(b). Lambdas are passed to a method expecting an interface with one method. Predicate is a common interface. It has one method named test that returns a boolean and takes any type. The removeIf() method on ArrayList takes a Predicate.

# Exam Essentials

- Be able to identify correct and incorrect method declarations. A sample method signature is public static void method(String... args) throws Exception {}.
- Identify when a method or field is accessible. Recognize when a method or field is accessed when the access modifier (private, protected, public, or default access) does not allow it.

- Recognize valid and invalid uses of static imports. Static imports import static members. They are written as import static, not static import. Make sure they are importing static methods or variables rather than classnames.

- State the output of code involving methods. Identify when to call static rather than instance methods based on whether the classname or object comes before the method. Recognize the correct overloaded method. Exact matches are used first, followed by wider primitives, followed by autoboxing, followed by varargs. Assigning new values to method parameters does not change the caller, but calling methods on them does.

- Evaluate code involving constructors. Constructors can call other constructors by calling this() as the first line of the constructor. Recognize when the default constructor is provided. Remember the order of initialization is the superclass, static variables/initializers, instance variables/initializers, and the constructor.

- Be able to recognize when a class is properly encapsulated. Look for private instance variables and public getters and setters when identifying encapsulation.

- Write simple lambda expressions. Look for the presence or absence of optional elements in lambda code. Parameter types are optional. Braces and the return keyword are optional when the body is a single statement. Parentheses are optional when only one parameter is specified and the type is implicit. The Predicate interface is commonly used with lambdas because it declares a single method called test(), which takes one parameter.