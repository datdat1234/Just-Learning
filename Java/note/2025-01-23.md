# Working with Periods

- Now we know enough to do something fun with dates! Our zoo performs animal enrichment activities to give the animals something fun to do. The head zookeeper has decided to switch the toys every month. This system will continue for three months to see how it works out.

- __Converting to a long__: Converting to a long LocalDate and LocalDateTime have a method to convert them into long equivalents in relation to 1970. What’s special about 1970? That’s what UNIX started using for date standards, so Java reused it. And don’t worry—you don’t have to memorize the names for the exam.
   - LocalDate has toEpochDay(), which is the number of days since January 1, 1970.
   - LocalDateTime has toEpochTime(), which is the number of seconds since January 1, 1970.
   - LocalTime does not have an epoch method. Since it represents a time that occurs on any date, it doesn’t make sense to compare it in 1970. Although the exam pretends time zones don’t exist, you may be wondering if this special January 1, 1970 is in a specific time zone. The answer is yes. This special time refers to when it was January 1, 1970 in GMT (Greenwich Mean Time). Greenwich is in England and GMT does not participate in daylight savings time. This makes it a good reference point. (Again, you don’t have to know about GMT for the exam.)

- Java has a Period class that we can pass in. This code does the same thing as the previous example:
```
public static void main(String[] args) {
 LocalDate start = LocalDate.of(2015, Month.JANUARY, 1);
 LocalDate end = LocalDate.of(2015, Month.MARCH, 30);
 Period period = Period.ofMonths(1); // create a period
 performAnimalEnrichment(start, end, period);
}
private static void performAnimalEnrichment(LocalDate start, LocalDate end,
 Period period) { // uses the generic period
 LocalDate upTo = start;
 while (upTo.isBefore(end)) {
 System.out.println("give new toy: " + upTo);
 upTo = upTo.plus(period); // adds the period
 }}
```

- The method can add an arbitrary period of time that gets passed in. This allows us to reuse the same method for different periods of time as our zookeeper changes her mind.

- There are five ways to create a Period class:
```
Period annually = Period.ofYears(1); // every 1 year
Period quarterly = Period.ofMonths(3); // every 3 months
Period everyThreeWeeks = Period.ofWeeks(3); // every 3 weeks
Period everyOtherDay = Period.ofDays(2); // every 2 days
Period everyYearAndAWeek = Period.of(1, 0, 7); // every year and 7 days
```

- There’s one catch. You cannot chain methods when creating a Period. The following
code looks like it is equivalent to the everyYearAndAWeek example, but it’s not. Only the last method is used because the Period.ofXXX methods are static methods.
```
Period wrong = Period.ofYears(1).ofWeeks(1); // every week
```

- This tricky code is really like writing the following:
```
Period wrong = Period.ofYears(1);
wrong = Period.ofWeeks(7);
```

- This is clearly not what you intended! That’s why the of() method allows us to pass in the number of years, months, and days. They are all included in the same period. You will get a compiler warning about this. Compiler warnings tell you something is wrong or suspicious without failing compilation.

- You’ve probably noticed by now that a Period is a day or more of time. There is also Duration, which is intended for smaller units of time. For Duration, you can specify the number of days, hours, minutes, seconds, or nanoseconds. And yes, you could pass 365 days to make a year, but you really shouldn’t—that’s what Period is for. Duration isn’t on the exam since it roughly works the same way as Period. It’s good to know it exists, though.

- The last thing to know about Period is what objects it can be used with. Let’s look at some code:
```
3: LocalDate date = LocalDate.of(2015, 1, 20);
4: LocalTime time = LocalTime.of(6, 15);
5: LocalDateTime dateTime = LocalDateTime.of(date, time);
6: Period period = Period.ofMonths(1);
7: System.out.println(date.plus(period)); // 2015-02-20
8: System.out.println(dateTime.plus(period)); // 2015-02-20T06:15
9: System.out.println(time.plus(period)); // UnsupportedTemporalTypeException
```

- Lines 7 and 8 work as expected. They add a month to January 20, 2015, giving us February 20, 2015. The first has only the date, and the second has both the date and time. Line 9 attempts to add a month to an object that only has a time. This won’t work. Java throws an exception and complains that we attempt to use an Unsupported unit: Months.

- As you can see, you’ll have to pay attention to the type of date and time objects every place you see them.

# Formatting Dates and Times

- The date and time classes support many methods to get data out of them:
```
LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
System.out.println(date.getDayOfWeek()); // MONDAY
System.out.println(date.getMonth()); // JANUARY
System.out.println(date.getYear()); // 2020
System.out.println(date.getDayOfYear()); // 20
```

- We could use this information to display information about the date. However, it would be more work than necessary. Java provides a class called DateTimeFormatter to help us out. Unlike the LocalDateTime class, DateTimeFormatter can be used to format any type of date and/or time object. What changes is the format. DateTimeFormatter is in the package java.time.format.
```
LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dateTime = LocalDateTime.of(date, time);
System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_TIME));
System.out.println(dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
```

- ISO is a standard for dates. The output of the previous code looks like this:
```
2020-01-20
11:12:34
2020-01-20T11:12:34
```

- This is a reasonable way for computers to communicate, but probably not how you want to output the date and time in your program. Luckily there are some predefined formats that are more useful:
```
DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
System.out.println(shortDateTime.format(dateTime)); // 1/20/20
System.out.println(shortDateTime.format(date)); // 1/20/20
System.out.println(shortDateTime.format(time)); // UnsupportedTemporalTypeException
```

- Here we say we want a localized formatter in the predefined short format. The last line throws an exception because a time cannot be formatted as a date. The format() method is declared on both the formatter objects and the date/time objects, allowing you to reference the objects in either order. The following statements print exactly the same thing as the previous code:
```
DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
System.out.println(dateTime.format(shortDateTime));
System.out.println(date.format(shortDateTime));
System.out.println(time.format(shortDateTime));
```

- In this book, we’ll change around the orders to get you used to seeing it both ways. Table below shows the legal and illegal localized formatting methods.

| DateTimeFormatter Method        | Calling f.format(localDate) | Calling f.format(localDateTime) | Calling f.format(localTime)  |
|----------------------------------|------------------------------|----------------------------------|-------------------------------|
| ofLocalizedDate                  | Legal – shows whole object   | Legal – shows just date part     | Throws runtime exception       |
| ofLocalizedDateTime              | Throws runtime exception      | Legal – shows whole object       | Throws runtime exception       |
| ofLocalizedTime                  | Throws runtime exception      | Legal – shows just time part     | Legal – shows whole object     |

- There are two predefined formats that can show up on the exam: SHORT and MEDIUM. The other predefined formats involve time zones, which are not on the exam.
```
LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dateTime = LocalDateTime.of(date, time);
DateTimeFormatter shortF = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);
DateTimeFormatter mediumF = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);
System.out.println(shortF.format(dateTime)); // 1/20/20 11:12 AM
System.out.println(mediumF.format(dateTime)); // Jan 20, 2020 11:12:34 AM
```

- If you don’t want to use one of the predefined formats, you can create your own. For example, this code spells out the month:
```
DateTimeFormatter f = DateTimeFormatter.ofPattern("MMMM dd, yyyy, hh:mm");
System.out.println(dateTime.format(f)); // January 20, 2020, 11:12
```

- Before we look at the syntax, know you are not expected to memorize what different numbers of each symbol mean. The most you will need to do is recognize the date and time pieces.
   - __MMMM__ M represents the month. The more Ms you have, the more verbose the Java output. For example, M outputs 1, MM outputs 01, MMM outputs Jan, and MMMM outputs January.
   - __dd__ d represents the date in the month. As with month, the more ds you have, the more verbose the Java output. dd means to include the leading zero for a single-digit month.
   - __,__ Use , if you want to output a comma (this also appears after the year).
   - __yyyy__ y represents the year. yy outputs a two-digit year and yyyy outputs a four-digit year.
   - __hh__ h represents the hour. Use hh to include the leading zero if you’re outputting a singledigit hour.
   - __:__ Use : if you want to output a colon.
   - __mm__ m represents the minute. 

- __Formatting Dates in Java 7 and Earlier__: Formatting is roughly equivalent to the “old way”; it just uses a different class.

| Action                    | Old Way                                      | New Way (Java 8 and Later)             |
|---------------------------|----------------------------------------------|----------------------------------------|
| Formatting the times      | SimpleDateFormat sf = new SimpleDateFormat("hh:mm"); | DateTimeFormatter f = DateTimeFormatter.ofPattern("hh:mm"); |
|                           | sf.format(jan3);                            | dt.format(f);                         |

- If you get this question on the exam, think about what the symbols represent. We have h for hour and m for minute. Remember M (uppercase) is month and m (lowercase) is minute. We can only use this formatter with objects containing times. Therefore, line 6 will throw an exception. 
```
4: DateTimeFormatter f = DateTimeFormatter.ofPattern("hh:mm");
5: f.format(dateTime);
6: f.format(date);
7: f.format(time);
```

# Parsing Dates and Times

- Now that you know how to convert a date or time to a formatted String, you’ll find it easy to convert a String to a date or time. Just like the format() method, the parse() method takes a formatter as well. If you don’t specify one, it uses the default for that type.
```
DateTimeFormatter f = DateTimeFormatter.ofPattern("MM dd yyyy");
LocalDate date = LocalDate.parse("01 02 2015", f);
LocalTime time = LocalTime.parse("11:22");
System.out.println(date); // 2015-01-02
System.out.println(time); // 11:22
```

- Here we show using both a custom formatter and a default value. This isn’t common, but you might have to read code that looks like this on the exam. Parsing is consistent in that if anything goes wrong, Java throws a runtime exception. That could be a format that doesn’t match the String to be parsed or an invalid date.

# Summary

- In this chapter, you learned that Strings are immutable sequences of characters. The new operator is optional. The concatenation operator (+) creates a new String with the content of the first String followed by the content of the second String. If either operand involved in the + expression is a String, concatenation is used; otherwise, addition is used. String literals are stored in the string pool. The String class has many methods. You need to know charAt(), concat(), endsWith(), equals(), equalsIgnoreCase(), indexOf(), length(), replace(), startsWith(), substring(), toLowerCase(), toUpperCase(), and trim().

- StringBuilders are mutable sequences of characters. Most of the methods return a reference to the current object to allow method chaining. The StringBuilder class has many methods. You need to know append(), charAt(), delete(), deleteCharAt(), indexOf(), insert(), length(), reverse(), substring(), and toString(). StringBuffer is the same as StringBuilder except that it is thread safe.

- Calling == on String objects will check whether they point to the same object in the pool. Calling == on StringBuilder references will check whether they are pointing to the same StringBuilder object. Calling equals() on String objects will check whether the sequence of characters is the same. Calling equals() on StringBuilder objects will check whether they are pointing to the same object rather than looking at the values inside.

- An array is a fixed-size area of memory on the heap that has space for primitives or pointers to objects. You specify the size when creating it—for example, int[] a = new int[6];. Indexes begin with 0 and elements are referred to using a[0]. The Arrays.sort() method sorts an array. Arrays.binarySearch() searches a sorted array and returns the index of a match. If no match is found, it negates the position where the element would need to be inserted and subtracts 1. Methods that are passed varargs (…) can be used as if a normal array was passed in. In a multidimensional array, the second-level arrays and beyond can be different sizes.

- An ArrayList can change size over its life. It can be stored in an ArrayList or List reference. Generics can specify the type that goes in the ArrayList. You need to know the methods add(), clear(), contains(), equals(), isEmpty(), remove(), set(), and size(). Although an ArrayList is not allowed to contain primitives, Java will autobox parameters passed in to the proper wrapper type. Collections.sort() sorts an ArrayList.

- A LocalDate contains just a date, a LocalTime contains just a time, and a LocalDateTime contains both a date and time. All three have private constructors and are created using LocalDate.now() or LocalDate.of() (or the equivalents for that class). Dates and times can be manipulated using plusXXX or minusXXX methods. The Period class represents a number of days, months, or years to add or subtract from a LocalDate or LocalDateTime. DateTimeFormatter is used to output dates and times in the desired format. The date and time classes are all immutable, which means the return value must be used.