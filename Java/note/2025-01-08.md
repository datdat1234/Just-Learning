- __Numeric Promotion__: In Chapter 1, “Java Building Blocks,” where we listed the primitive numeric types, each primitive has a bit-length. You don’t need to know the exact size of these types for the exam, but you should know which are bigger than others. For example, you should know that a long takes up more space than an int, which in turn takes up more space than a short, and so on.

- You should memorize certain rules Java will follow when applying operators to data types:
1. If two values have different data types, Java will automatically promote one of the values to the larger of the two data types.
2. If one of the values is integral and the other is floating-point, Java will automatically promote the integral value to the floating-point value’s data type.
3. Smaller data types, namely byte, short, and char, are first promoted to int any time they’re used with a Java binary arithmetic operator, even if neither of the operands is int.
4. After all promotion has occurred and the operands have the same data type, the resulting value will have the same data type as its promoted operands.

- For the third rule, note that unary operators are excluded from this rule. For example, applying ++ to a short value results in a short value. We’ll discuss unary operators in the next section.

- By definition, a *unary* operator is one that requires exactly one operand, or variable, to function.
| Unary Operator | Description                                                                                           |
|----------------|-------------------------------------------------------------------------------------------------------|
| `+`            | Indicates a number is positive; numbers are assumed to be positive in Java unless accompanied by a negative unary operator. |
| `-`            | Indicates a literal number is negative or negates an expression.                                      |
| `++`           | Increments a value by 1.                                                                             |
| `--`           | Decrements a value by 1.                                                                             |
| `!`            | Inverts a Boolean’s logical value.                                                                    |

- The *logical complement operator*, !, flips the value of a boolean expression. For example, if the value is true, it will be converted to false, and vice versa. 

- Likewise, the negation operator, -, reverses the sign of a numeric expression.

- Based on the description, it might be obvious that some operators require the variable or expression they’re acting upon to be of a specific type. For example, you cannot apply a negation operator, -, to a boolean expression, nor can you apply a logical complement operator, !, to a numeric expression. Be wary of questions on the exam that try to do this, as they’ll cause the code to fail to compile. For example, none of the following lines of code will compile:
```
int x = !5; // DOES NOT COMPILE
boolean y = -true; // DOES NOT COMPILE
boolean z = !0; // DOES NOT COMPILE
```

- The first statement will not compile due the fact that in Java you cannot perform a logical inversion of a numeric value. The second statement does not compile because you cannot numerically negate a boolean value; you need to use the logical inverse operator. Finally, the last statement does not compile because you cannot take the logical complement of a numeric value, nor can you assign an integer to a boolean variable.

- Keep an eye out for questions on the exam that use the logical complement operator or numeric values with boolean expressions or variables. Unlike some other programming languages, in Java 1 and true are not related in any way, just as 0 and false are not related.

- __Increment and Decrement Operators__: Increment and decrement operators, ++ and --, respectively, can be applied to numeric operands and have the higher order or precedence, as compared to binary operators. In other words, they often get applied first to an expression.

- Increment and decrement operators require special care because the order they are applied to their associated operand can make a difference in how an expression is processed. If the operator is placed before the operand, referred to as the pre-increment operator and the pre-decrement operator, then the operator is applied first and the value return is the new value of the expression. Alternatively, if the operator is placed after the operand, referred to as the post-increment operator and the post-decrement operator, then the original value of the expression is returned, with operator applied after the value is returned.

- __Assignment Operators__: An *assignment operator* is a binary operator that modifies, or assigns, the variable on the left-hand side of the operator, with the result of the value on the right-hand side of the equation.

- Java will automatically promote from smaller to larger data types, as we saw in the previous section on arithmetic operators, but it will throw a compiler exception if it detects you are trying to convert from larger to smaller data types.
```
int x = 1.0; // DOES NOT COMPILE
short y = 1921222; // DOES NOT COMPILE
int z = 9f; // DOES NOT COMPILE
long t = 192301398193810323; // DOES NOT COMPILE
```

-  The first statement does not compile because you are trying to assign a double 1.0 to an integer value. Even though the value is a mathematic integer, by adding .0, you’re instructing the compiler to treat it as a double. The second statement does not compile because the literal value 1921222 is outside the range of short and the compiler detects this. The third statement does not compile because of the f added to the end of the number that instructs the compiler to treat the number as floating-point value. Finally, the last statement does not compile because Java interprets the literal as an int and notices that the value is larger than int allows. The literal would need a postfix L to be considered a long. 

- __Casting Primitive Values__: We can fix the examples in the previous section by casting the results to a smaller data type. Casting primitives is required any time you are going from a larger numerical data type to a smaller numerical data type, or converting from a floating-point number to an integral value.
```
int x = (int)1.0;
short y = (short)1921222; // Stored as 20678
int z = (int)9l;
long t = 192301398193810323L;
```

- __Overflow and Underflow__: The expressions in the previous example now compile, although there’s a cost. The second value, 1,921,222, is too large to be stored as a short, so numeric overflow occurs and it becomes 20,678. Overflow is when a number is so large that it will no longer fit within the data type, so the system “wraps around” to the next lowest value and counts up from there. There’s also an analogous underflow, when the number is too low to fit in the data type. This is beyond the scope of the exam, but something to be careful of in your own code. For example, the following statement outputs a negative number:
```
System.out.print(2147483647+1); // -2147483648
```

- Since 2147483647 is the maximum int value, adding any strictly positive value to it will cause it to wrap to the next negative number.

- Based on everything you have learned up until now, can you understand why the last line of this statement will not compile? If you remember, short values are automatically promoted to int when applying any arithmetic operator, with the resulting value being of type int. Trying to set a short variable to an int results in a compiler error, as Java thinks you are trying to implicitly convert from a larger data type to a smaller one.
```
short x = 10;
short y = 3;
short z = x * y; // DOES NOT COMPILE
```

- By performing this explicit cast of a larger value into a smaller data type, you are instructing the compiler to ignore its default behavior. In other words, you are telling the compiler that you have taken additional steps to prevent overflow or underflow. It is also possible that in your particular application and scenario, overflow or underflow would result in acceptable values.
```
short x = 10;
short y = 3;
short z = (short)(x * y);
```

- __Compound Assignment Operators__: Besides the simple assignment operator, =, there are also numerous compound assignment operators. Only two of the compound operators listed before are required for the exam, += and -=. Complex operators are really just glorified forms of the simple assignment operator, with a built-in arithmetic or logical operation that applies the left- and right-hand sides of the statement and stores the resulting value in a variable in the left-hand side of the statement. 

- The left-hand side of the compound operator can only be applied to a variable that is already defined and cannot be used to declare a new variable.

- Compound operators are useful for more than just shorthand—they can also save us from having to explicitly cast a value.
```
// EX1
long x = 10;
int y = 5;
y = y * x; // DOES NOT COMPILE

// EX2
long x = 10;
int y = 5;
y *= x;
```

- The compound operator will first cast x to a long, apply the multiplication of two long values, and then cast the result to an int. Unlike the previous example, in which the compiler threw an exception, in this example we see that the compiler will automatically cast the resulting value to the data type of the value on the left-hand side of the compound operator.

- One final thing to know about the assignment operator is that the result of the assignment is an expression in and of itself, equal to the value of the assignment. For example, the following snippet of code is perfectly valid, if not a little odd looking:
```
long x = 5;
long y = (x=3);
System.out.println(x); // Outputs 3
System.out.println(y); // Also, outputs 3
```

- __Relational Operators__: We now move on to relational operators, which compare two expressions and return a boolean value. The first four relational operators (see Table below) are applied to numeric primitive data types only. If the two numeric operands are not of the same data type, the smaller one is promoted in the manner as previously discussed.
| Operator | Description                         |
|----------|-------------------------------------|
| `<`      | Strictly less than                 |
| `<=`     | Less than or equal to              |
| `>`      | Strictly greater than              |
| `>=`     | Greater than or equal to           |

- The fi fth relational operator (Table below) is applied to object references and classes or interfaces:
| Operator      | Description                                                                                                                                   |
|---------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| `a instanceof b` | True if the reference that `a` points to is an instance of a class, subclass, or class that implements a particular interface, as named in `b`. |

- The instanceof operator, while useful for determining whether an arbitrary object is a member of a particular class or interface, is out of scope for the OCA exam.