#### Applying Lazy Instantiation to Singletons

Another technique is to delay creation of the singleton until the first time the getInstance() method is called:

```java
// Lazy instantiation
public class VisitorTicketTracker {
    private static VisitorTicketTracker instance;
    private VisitorTicketTracker() {
    }
    public static VisitorTicketTracker getInstance() {
        if(instance == null) {
            instance = new VisitorTicketTracker(); // NOT THREAD-SAFE!
        }
        return instance;
    }
    // Data access methods
}
```

The VisitorTicketTracker, like our singleton classes, declares only private constructors, creates a singleton instance, and returns the singleton with a getInstance() method. The VisitorTicketTracker class, though, does not create the singleton object when the class is loaded but rather the first time it is requested by a client. Creating a reusable object the first time it is requested is a software design pattern known as lazy instantiation. It used often in conjunction with the singleton pattern.

Lazy instantiation reduces memory usage and improves performance when an application starts up. In fact, without lazy instantiation, most operating systems and applications that you run would take significantly longer to load and consume a great deal more memory, perhaps more memory than is even available on your computer. The downside of lazy instantiation is that users may see a noticeable delay the first time a particular type of resource is needed.

For example, you may have seen lazy instantiation in applications that you use to write software and not even noticed it. One such freely available software development tool, Eclipse, often demonstrates a slight delay the first time you open a Java file in an editor window after starting the program. This delay disappears, though, when you open additional Java files. This is an example of lazy instantiation, since Eclipse is only loading the libraries to parse and present Java files the first time a Java file is open.

__Singletons in server environments__: For the purposes of the exam, singletons are always unique. When you get to writing applications that run across multiple computers, the static singleton solution starts to require special consideration, as each computer would have its own JVM.

In those situations, you might still use the singleton pattern, although it might be implemented with a database or queue server rather than as a static object. However, the discussion of which to employ is beyond the scope of the exam.

#### Creating Unique Singletons

To truly implement the singleton pattern, we must ensure that only one instance of the singleton is ever created. Marking the constructor private is a good first step as it prevents the singleton from being created by other classes, but we also need to ensure that the object is only created once within the singleton class itself. We guaranteed this in the HayStorage and StaffRegister classes by using the final modifier on the static reference.

Unfortunately, because we used lazy instantiation in the VisitorTicketTracker class, the compiler won’t let us assign the final modifier to the static reference. The implementation of VisitorTicketTracker, as shown, is not considered thread‐safe in that two threads could call getInstance() at the same time, resulting in two objects being created. After both threads finish executing, only one object will be set and used by other threads going forward, but the object that the two initial threads received may not be the same.

Thread safety is the property of an object that guarantees safe execution by multiple threads at the same time. We will discuss thread safety in Chapter 7, but for now we present a simple solution that is compatible with lazy instantiation using the synchronized modifier:

```java
public static synchronized VisitorTicketTracker getInstance() {
    if(instance == null) {
        instance = new VisitorTicketTracker();
    }
    return instance;
}
```

The getInstance() method is now synchronized, which means only one thread will be allowed in the method at a time, ensuring that only one object is created.

__Singletons with Double‐Checked locking__: The synchronized implementation of getInstance(), while correctly preventing multiple singleton objects from being created, has the problem that every single call to this method will require synchronization. In practice, this can be costly and can impact performance. Synchronization is only needed the first time that the object is created.

The solution is to use double‐checked locking, a design pattern in which we first test if synchronization is needed before actually acquiring any locks. The following is an example rewrite of this method using double‐checked locking:

```java
private static volatile VisitorTicketTracker instance;
public static VisitorTicketTracker getInstance() {
    if(instance == null) {
        synchronized(VisitorTicketTracker.class) {
            if(instance == null) {
                instance = new VisitorTicketTracker();
            }
        }
    }
    return instance;
}
```

As you may have noticed, we added the volatile modifier to our singleton object. This keyword prevents a subtle case where the compiler tries to optimize the code such that that the object is accessed before it is finished being constructed. For the exam, you are not required to know how volatile works or about any compiler optimizations.

This solution is better than our previous version, as it performs the synchronization step only when the singleton does not exist. If our singleton is accessed thousands of times over many hours or days, this means that only the first few calls would require synchronization, and the rest would not.

### Creating Immutable Objects

__Problem__ How do we create read‐only objects that can be shared and used by multiple classes?

__Motivation__ Sometimes we want to create simple objects that can be shared across multiple classes, but for security reasons we don’t want their value to be modified. We could copy the object before sending it to another method, but this creates a large overhead that duplicates the object every time it is passed. Furthermore, if we have multiple threads accessing the same object, we could run into concurrency issues, as you will see in Chapter 7.

__Solution__ The immutable object pattern is a creational pattern based on the idea of creating objects whose state does not change after they are created and can be easily shared across multiple classes. Immutable objects go hand and hand with encapsulation, except that no setter methods exist that modify the object. Since the state of an immutable object never changes, they are inherently thread‐safe.

#### Applying an Immutable Strategy

Although there are a variety of techniques for writing an immutable class, you should be familiar with a common strategy for making a class immutable for the exam:
   - Use a constructor to set all properties of the object.
   - Mark all of the instance variables private and final.
   - Don’t define any setter methods.
   - Don’t allow referenced mutable objects to be modified or accessed directly.
   - Prevent methods from being overridden.

The first rule defines how we create the immutable object, by passing the information to the constructor, so that all of the data is set upon creation. The second and third rules are straightforward, as they stem from proper encapsulation. If the instance variables are private and final, and there are no setter methods, then there is no direct way to change the property of an object. All references and primitive values contained in the object are set at creation and cannot be modified.

The fourth rule requires a little more explanation. Let’s say that you have an immutable Animal object, which contains a reference to a List of the animal’s favorite foods, as shown in the following example:

```java
import java.util.*

public final class Animal {
    private final List<String> favoriteFoods;
    public Animal(List<String> favoriteFoods) {
        if(favoriteFoods == null) {
            throw new RuntimeException("favoriteFoods is required");
        }
        this.favoriteFoods = new ArrayList<String>(favoriteFoods);
    }
    public List<String> getFavoriteFoods() { // MAKES CLASS MUTABLE!
        return favoriteFoods;
    }
}
```

In order to ensure that the favoriteFoods List is not null, we validate it in the constructor and throw an exception if it is not provided. The problem in this example is that the user has direct access to the List defined in our instance of Animal. Even though they can’t change the List object to which it points, they can modify the items in the List, for example, deleting all of the items by calling getFavoriteFoods().clear(). They
could also replace, remove, or even sort the List.

The solution, then, is never to return that List reference to the user. More generally stated, you should never share references to a mutable object contained within an immutable object. If the user does need access to the data in the List, either create wrapper methods to iterate over the data or create a one‐time copy of the data that is returned to the user and never stored as part of the object. In fact, the Collections API includes the Collections.unmodifiableList() method, which does exactly this. The key here is that none of the methods that you create should modify the mutable object.

Returning to our five rules, the last rule is important because it prevents someone from creating a subclass of your class in which a previously immutable value now appears mutable. For example, they could override a method that modifies a different variable in the subclass, essentially hiding the private variable defined in the parent class. The simplest solution is to mark the class or methods with the final modifier, although this does limit the usage of the class. Another option is to make the constructor private and apply the factory pattern, which we will discuss later in this chapter.

__Handling mutable Objects in the Constructors of immutable Objects__: You may notice that we created a new ArrayList in the Animal constructor. This is absolutely important to prevent the class that initially creates the object from maintaining a reference to the mutable List used by Animal. Consider if we had just done the following in the constructor:

```java
this.favoriteFoods = favoriteFoods;
```

With this change, the caller that creates the object is using the same reference as the immutable object, which means that it has the ability to change the List! It is important when creating immutable objects that any mutable input arguments are copied to the instance instead of being used directly.

#### “Modifying” an Immutable Object

How do we modify immutable objects if they are inherently unmodifiable? The answer is, we can’t! Alternatively, we can create new immutable objects that contain all of the same information as the original object plus whatever we wanted to change. This happens every time we combine two strings:

```java
String firstName = "Grace";
String fullName = firstName + " Hopper";
```

In this example, the firstName is immutable and is not modified when added to the fullName, which is also an immutable object. We can also do the same thing with our Animal class. Imagine that we want to increase the age of an Animal by one. The following creates two Animal instances, the second using a copy of the data from the first instance:

```java
/ Create a new Animal instance
Animal lion = new Animal("lion", 5, Arrays.asList("meat","more meat"));
// Create a new Animal instance using data from the first instance
List<String> favoriteFoods = new ArrayList<String>();
for(int i=0; i<lion.getFavoriteFoodsCount(); i++) {
    favoriteFoods.add(lion.getFavoriteFood(i));
}
Animal updatedLion = new Animal(lion.getSpecies(), lion.getAge()+1, favoriteFoods);
```

Since we did not have direct access to the favoriteFoods mutable List, we had to copy it using the methods available in the immutable class. We could also simplify this by defining a method in Animal that returns a copy of the favoriteFood List, provided that the caller understands that modifying this copied List does not change the original Animal object in any way.

### Using the Builder Pattern

__Problem__ How do we create an object that requires numerous values to be set at the time the object is instantiated?

__Motivation__ As our data objects grow in size, the constructor may grow to contain many attributes. For example, in our most recent immutable Animal class example, we had three input parameters: species, age, and favoriteFoods. If we want to add five new attributes to the object, we’d have to add five new values in the constructor. Every time we add a parameter, the constructor grows! Users who reference our object would also be required to update their constructor calls each time that the object was modified, resulting in a class that would be difficult to use and maintain. Alternatively, we could add a new constructor each time we add a parameter, but having too many constructors can be quite difficult to manage in practice.

One solution is to use setter methods instead of the constructor to configure the object, but this doesn’t work for immutable objects since they can’t be modified after creation. For mutable objects, it could also lead to class invariants being temporarily broken. For example, the attributes of the class may be dependent on each other, and setting them one at a time may expose a state where the object is not properly configured.

__Introducing anti‐Patterns__: The problem of a constructor growing too large actually has a name, referred to as the telescoping constructor anti‐pattern. An anti‐pattern is a common solution to a reoccurring problem that tends to lead to unmanageable or difficult‐to‐use code. Anti‐patterns often appear in complex systems as time goes on, when developers implement a series of successive changes without considering the long‐term effects of their actions.

For example, with the telescoping constructor anti‐pattern, the class may start off with only two parameters in the constructor. Another developer may come in and added another parameter, thinking “It’s only one more!” A third developer may update the class and add a fourth parameter, and so on, until the class has 50 or 60 parameters in the constructor and is in desperate need of rewriting, also called refactoring.

The reason why this is an anti‐pattern is that each time the class is modified, the developer is only doing minor damage to the class. However, it eventually grows out of control. If the class is used in a number of important places throughout the system, refactoring it may become difficult—in some cases nearly impossible. Design patterns are often written to help prevent anti‐patterns from forming.