1. A. Based on the equals() method in the code, objects are equal if they have the same employeeId. The hashCode() method correctly overrides the one from Object. The equals() method is an overload of the one from Object and not an override. It would be better to pass Object since an override would be better to use here. It is odd to override hashCode() and not equals().
2. A. hashCode() is correct and perfectly reasonable given that equals() also checks that field. ClassCastException is a runtime exception and therefore does not need to be handled or declared. The override in equals() is correct. It is common for equals() to refer to a private instance variable. This is legal because it is within the same class, even if it is referring to a different object of the same class.
3. C. s1 points to the string pool. s2 points to an object on the heap, since it is created at runtime. == checks for reference equality. These are different references, making B incorrect. String overrides equals() so the actual values are the same, making C correct. And yes, this question could have appeared on the OCA. Remember that the OCP is cumulative. A question may appear to be about one thing and actually be about a simpler concept.
4. C. The equals() method is correct. You are allowed to use any business logic that you want in determining equality. The hashCode() method is not correct. It violates the rule that two objects that return true for equals() must return the same hashCode(). It is also a bad idea for the hash code to contain values that could change.
5. A, D. The relevant rule is that two objects that return true for equals() objects must return the same hash code. Therefore A is correct and B is incorrect. Two objects with the same hash code may or may not be equal. This makes C incorrect and D correct. The fact that two objects are not equal does not guarantee or preclude them from sharing a hash code. Remember that hashCode() tells you which bucket to look in and equals() tells you whether you have found an exact match.
6. B
7. E
8. C. Inner is a member inner class. Inner classes are not allowed to contain static methods or static variables. Only nested static classes are permitted to contain statics.
9. B. Outer.this.x is the correct way to refer to x in the Outer class. In Java 7, the answer would have been D because you used to have to declare variables as final to use them in a local inner class. In Java 8, this requirement was dropped and the variables only need to be effectively final, which means that the code would still compile if final were added.
10. C. The code compiles fine. A member inner class is allowed to be private, and it is allowed to refer to instance variables from the outer class. Two .class files are generated. Book.class matches the name of the outer class. The inner class does not compile to BookReader.class. That would introduce the possibility of a naming conflict. Book$BookReader.class is correct because it shows the scope of the class is limited to Book. You donâ€™t need to know that $ is the syntax, but you do need to know the number of classes and that BookReader is not a top-level class.