# Generics and Collections

## Reviewing OCA Collections

The Java Collections Framework includes classes that implement List, Map, Queue, and Set. On the OCA, you saw one such class. The class ArrayList implements the interface List. You will learn about more of these later in this chapter. You also saw arrays on the OCA, such as int[]. An array is not part of the Collections Framework. Since sorting and searching are similar between lists and arrays, both are covered on the exam. Furthermore, since the OCP is cumulative, you are still expected to know how to work with arrays from the OCA.

### Array and ArrayList

An ArrayList is an object that contains other objects. An ArrayList cannot contain primitives. An array is a built-in data structure that contains other objects or primitives.

Java counts starting with 0 for indexes. It also reminds us that we access elements in ArrayLists with get(), and we check the number of elements with size(). By contrast, we access elements in arrays using brackets and check the number of elements with the length variable.

Line 5 converts an array to a List. It happens to be an implementation of List that is not an ArrayList. Remember that a List is like a resizable array. It makes sense to convert an array to a List. It doesn’t make sense to convert an array to a Set. You still can do so, however, although it takes an extra step. You’d have to convert the array to a List and then the List to a Set. Lines 6 and 7 show that you can change the elements in either the array or the List. Changes are reflected in both, since they are backed by the same data.

Implementations of List are allowed to add their own behavior. The implementation used when calling asList() has the added feature of not being resizable but honoring all of the other methods in the interface. Line 8 converts the List back to an array. Finally, line 9 shows that list is not resizable because it is backed by the underlying array.

### Searching and Sorting

```java
11: int[] numbers = {6,9,1,8};
12: Arrays.sort(numbers); // [1,6,8,9]
13: System.out.println(Arrays.binarySearch(numbers, 6)); // 1
14: System.out.println(Arrays.binarySearch(numbers, 3)); // -2
```

Line 12 sorts the array because binary search assumes the input is sorted. Line 13 prints the index at which a match is found. Line 14 prints one less than the negated index of where the requested value would need to be inserted. The number 3 would need to be inserted at index 1 (after the number 1 but before the number 6). Negating that gives us -1 and subtracting 1 gives us -2.

We call sort() and binarySearch() on Collections rather than Collection. In the past, Collection could not have concrete methods because it is an interface. Some were added in Java 8. We will explore these in Chapter 4 , “Functional Programming.” Keep this change in mind if you practice with any older mock exams.

### Wrapper Classes and Autoboxing

As a brief review, each primitive has a corresponding wrapper class, as shown in Table below. Autoboxing automatically converts a primitive to the corresponding wrapper classes when needed if the generic type is specified in the declaration. Unsurprisingly, unboxing automatically converts a wrapper class back to a primitive.

| Primitive Type | Wrapper Class | Example                  |
|----------------|---------------|--------------------------|
| boolean        | Boolean       | `new Boolean(true)`      |
| byte           | Byte          | `new Byte((byte) 1)`     |
| short          | Short         | `new Short((short) 1)`    |
| int            | Integer       | `new Integer(1)`         |
| long           | Long          | `new Long(1)`            |
| float          | Float         | `new Float(1.0)`         |
| double         | Double        | `new Double(1.0)`        |
| char           | Character     | `new Character('c')`     |

### The Diamond Operator

Java has come a long way. Before Java 5 came out, you had to write code like the following and hope that programmers remembered that you wanted only String objects in there:

```java
List names = new ArrayList();
```

This required a bit of mind reading. You had no way of knowing names were expected to contain String objects rather than StringBuilder or something else. In Java 5, you could actually document this assumption in code through a new feature called generics! The compiler even helps enforce this assumption for you:

```java
List<String> names = new ArrayList<String>();
```

When Java 7 came out, its developers made it even better. The previous statement required you to type six extra characters (String). Java 7 lets you shorten it a bit:

```java
List<String> names = new ArrayList<>();
```

The shortened form uses the diamond operator. It is called that because <> looks like a diamond if you tilt your head to the side.

You may laugh a bit about saving six characters. The diamond operator becomes more helpful if you have more complex code. By the end of the chapter, you’ll know how to write code like this:

```java
HashMap<String, HashMap<String, String>> map1 = new HashMap<String, HashMap<String, String>>();
HashMap<String, HashMap<String, String>> map2 = new HashMap<>();
```

Both of these statements contain a nested map. The second line is a lot easier to read because it doesn’t contain the redundant type information. In case you are wondering, this nested map arrangement might be useful if you have a number of data caches that you want to query by key.

The diamond operator isn’t limited to one-line declarations. In this example, you can see it used with an instance variable and a local variable:

```java
import java.util.*;
class Doggies {
    List<String> names;
    Doggies() {
        names = new ArrayList<>(); // matches instance variable declaration
    }
    public void copyNames() {
        ArrayList<String> copyOfNames;
        copyOfNames = new ArrayList<>(); // matches local variable declaration
    } 
}
```

## Working with Generics

### Generic Classes

You can introduce generics into your own classes. The syntax for introducing a generic is to declare a formal type parameter in angle brackets. For example, the following class named Crate has a generic type variable declared after the name of the class:

```java
public class Crate<T> {
    private T contents;
    public T emptyCrate() {
        return contents;
    }
    public void packCrate(T contents) {
        this.contents = contents;
    }
}
```

The generic type T is available anywhere within the Crate class. When you instantiate the class, you tell the compiler what T should be for that particular instance.

__Naming Conventions for Generics__: A type parameter can be named anything you want. The convention is to use single uppercase letters to make it obvious that they aren’t real class names. The following are common letters to use:
   - E for an element
   - K for a map key
   - V for a map value
   - N for a number
   - T for a generic data type
   - S, U, V, and so forth for multiple generic types

Now we couldn’t have simply hard-coded Elephant in the Crate class, since a Zebra is not an Elephant. However, we could have created an Animal superclass or interface and used that in Crate.

Generic classes become useful when the classes used as the type parameter can have absolutely nothing to do with each other. 

Now it is starting to get interesting. The Crate class works with any type of class. Before generics, we would have needed Crate to use the Object class for its instance variable, which would have put the burden on the caller of needing to cast the object it receives on emptying the crate.

In addition to Crate not needing to know about the objects that go into it, those objects don’t need to know about Crate either. We aren’t requiring the objects to implement an interface named Crateable or the like. A class can be put in the Crate without any changes at all.

Don’t worry if you can’t think of a use for generic classes of your own. Unless you are writing a library for others to reuse, generics hardly show up in the class definitions you write. They do show up frequently in the code you call, such as the Java Collections Framework.

Generic classes aren’t limited to having a single type parameter. This class shows two generic parameters:

```java
public class SizeLimitedCrate<T, U> {
    private T contents;
    private U sizeLimit;
    public SizeLimitedCrate(T contents, U sizeLimit) {
        this.contents = contents;
        this.sizeLimit = sizeLimit;
    } 
}
```

T represents the type that we are putting in the crate. U represents the unit that we are using to measure the maximum size for the crate. To use this generic class, we can write the following:

```java
Elephant elephant = new Elephant();
Integer numPounds = 15_000;
SizeLimitedCrate<Elephant, Integer> c1 = new SizeLimitedCrate<>(elephant,
numPounds);
```

__Type erasure__: Specifying a generic type allows the compiler to enforce proper use of the generic type. For example, specifying the generic type of Crate as Robot is like replacing the T in the Crate class with Robot. However, this is just for compile time.

Behind the scenes, the compiler replaces all references to T in Crate with Object. In other words, after the code compiles, your generics are actually just Object types. The Crate class looks like the following:

```java
public class Crate {
    private Object contents;
    public Object emptyCrate() {
        return contents;
    }
    public void packCrate(Object contents) {
        this.contents = contents;
    }
}
```

This means there is only one class file. There aren’t different copies for different parameterized types. (Some other languages work that way.)

This process of removing the generics syntax from your code is referred to as type erasure. Type erasure allows your code to be compatible with older versions of Java that do not contain generics.

The compiler adds the relevant casts for your code to work with this type of erased class. For example, you type

```java
Robot r = crate.emptyCrate();
```

and the compiler turns it into

```java
Robot r = (Robot) crate.emptyCrate();
```

### Generic Interfaces

Just like a class, an interface can declare a formal type parameter. For example, the following Shippable interface uses a generic type as the argument to its ship() method:

```java
public interface Shippable<T> {
    void ship(T t);
}
```

There are three ways a class can approach implementing this interface. The first is to specify the generic type in the class. The following concrete class says that it deals only with robots. This lets it declare the ship() method with a Robot parameter:

```java
class ShippableRobotCrate implements Shippable<Robot> {
    public void ship(Robot t) { }
}
```

The next way is to create a generic class. The following concrete class allows the caller to specify the type of the generic:

```java
class ShippableAbstractCrate<U> implements Shippable<U> {
    public void ship(U t) { }
}
```

The final way is to not use generics at all. This is the old way of writing code. It generates a compiler warning about Shippable being a raw type, but it does compile. Here the ship() method has an Object parameter since the generic type is not defined:

```java
class ShippableCrate implements Shippable {
    public void ship(Object t) { }
}
```

__What You Can’t do with Generic Types__: There are some limitations on what you can do with a generic type. These aren’t on the exam, but it will helpful to refer back to this scenario when you are writing practice programs and run into one of these.

Most of the limitations are due to type erasure. Oracle refers to types whose information is fully available at runtime as reifiable. Reifiable types can do anything that Java allows. Non-reifiable types have some limitations.

Here are the things that you can’t do with generics. (And by “can’t,” we mean without resorting to contortions like passing in a class object.)
   - Call the constructor. new T() is not allowed because at runtime it would be new Object().
   - Create an array of that static type. This one is the most annoying, but it makes sense because you’d be creating an array of Objects.
   - Call instanceof. This is not allowed because at runtime `List<Integer>` and `List<String>` look the same to Java thanks to type erasure.
   - Use a primitive type as a generic type parameter. This isn’t a big deal because you can use the wrapper class instead. If you want a type of int, just use Integer.
   - Create a static variable as a generic type parameter. This is not allowed because the type is linked to the instance of the class.

### Generic Methods

Up until this point, you’ve seen formal type parameters declared on the class or interface level. It is also possible to declare them on the method level. This is often useful for static methods since they aren’t part of an instance that can declare the type. However, it is also allowed on non-static methods as well.

```java
public static <T> Crate<T> ship(T t) {
    System.out.println("Preparing " + t);
    return new Crate<T>();
}
```

The method parameter is the generic type T. The return type is a `Crate<T>`. Before the return type, we declare the formal type parameter of `<T>`.

Unless a method is obtaining the generic formal type parameter from the class/interface, it is specified immediately before the return type of the method. This can lead to some interesting-looking code!

```java
3: public static <T> void sink(T t) { }
4: public static <T> T identity(T t) { return t; }
5: public static T noGood(T t) { return t; } // DOES NOT COMPILE
```

Line 3 shows the formal parameter type immediately before the return type of void. Line 4 shows the return type being the formal parameter type. It looks weird, but it is correct. Line 5 omits the formal parameter type, and therefore it does not compile.

__Optional syntax for invoking a Generic method__: You can call a generic method normally, and the compiler will figure out which one you want. Alternatively, you can specify the type explicitly to make it obvious what the type is:

```java
Box.<String>ship("package");
Box.<String[]>ship(args)
```

As to whether this makes things clearer, it is up to you. You should at least be aware that this syntax exists.