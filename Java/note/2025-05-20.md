### Purpose of an Interface

An interface provides a way for one individual to develop code that uses another individual’s code, without having access to the other individual’s underlying implementation. Interfaces can facilitate rapid application development by enabling development teams to create applications in parallel, rather than being directly dependent on each other.

__Mock Objects__: ou might wonder how a developer using the interface can build their code without access to a class that implements the interface. The developer using the interface can create a temporary mock object, sometimes referred to as dummy code, which simulates the real object that implements the interface with a simple implementation. The mock object does not need to be very complex, with one line per abstract method, for example, as it only serves as a placeholder for the real implementation. This allows the developer using the interface to compile, run, and test their code.

For example, imagine that you were working on a racing application with the code that calculates the winners handled by a different team. Both your team and the other team agreed on a RaceManager interface, as shown in the following code, with your team using the interface and the other team implementing it:

```java
public class Animal {}
public class Tortoise extends Animal {}
public class Hare extends Animal {}
public interface RaceManager {
  public Animal getWinner(List<Animal> animals);
}
```

The good news is that your team has finished its part of the project first. The bad news is that the other team has nothing for you to test with. While waiting for the other team to finish, you can create a mock version of the RaceManager class, as shown in the following sample code:

```java
public class DummyRaceManager implements RaceManager {
  public Animal getWinner(List<Animal> animals) {
    return animals==null || animals.size()==0 ? null: animals.get(0);
  }
}
```

The code isn’t particularly intelligent; after all it just returns the first item in the list, but it is useful for testing purposes because it allows your team to execute your code while the other team finishes their implementation. You could also write a version that always returns Tortoise or Hare. The goal is just to give you something temporary that you can work with and that allows your code to compile, regardless of whether it works exactly as expected. After all, the full implementation of getWinner() could be hundreds of lines long and based on very complex business rules.

## Introducing Functional Programming

Java defines a functional interface as an interface that contains a single abstract method.

Functional interfaces are used as the basis for lambda expressions in functional programming.

A lambda expression is a block of code that gets passed around, like an anonymous method.

### Defining a Functional Interface

```java
@FunctionalInterface
public interface Sprint {
  public void sprint(Animal animal);
}

public class Tiger implements Sprint {
  public void sprint(Animal animal) {
    System.out.println("Animal is sprinting fast! "+animal.toString());
  }
}
```

In this example, the Sprint class is a functional interface, because it contains exactly one abstract method, and the Tiger class is a valid class that implements the interface.

__Applying the @FunctionalInterface Annotation__: While it is a good practice to mark a functional interface with the @FunctionalInterface annotation for clarity, it is not required with functional programming. The Java compiler implicitly assumes that any interface that contains exactly one abstract method is a functional interface. Conversely, if a class marked with the @FunctionalInterface annotation contains more than one abstract method, or no abstract methods at all, then the compiler will detect this error and not compile.

One problem with not always marking your functional interfaces with this annotation is that another developer may treat any interface you create that has only one method as a functional interface. If you later modify the interface to have other abstract methods, suddenly their code will break since it will no longer be a functional interface.

Therefore, it is recommend that you explicitly mark the interface with the @FunctionalInterface annotation so that other developers know which interfaces they can safely apply lambdas to without the possibility that they may stop being functional interfaces down the road.

The exam writers aren’t likely to use this annotation, as they expect you to be able to determine whether an interface is a functional interface on your own.

Applying the @FunctionalInterface annotation to any interfaces that do not contains exactly one abstract method would result in a compiler error, as would attempting to use them implicitly as functional interfaces in a lambda expression.

### Implementing Functional Interfaces with Lambdas

As we said earlier, a lambda expression is a block of code that gets passed around, like an anonymous method. Let’s start with a simple CheckTrait functional interface, which has a single method test(), which takes as input an instance of an Animal class. The definitions of the class and functional interface are as follows:

```java
public class Animal {
  private String species;
  private boolean canHop;
  private boolean canSwim;
  public Animal(String speciesName, boolean hopper, boolean swimmer) {
    species = speciesName;
    canHop = hopper;
    canSwim = swimmer;
  }
  public boolean canHop() { return canHop; }
  public boolean canSwim() { return canSwim; }
  public String toString() { return species; }
}

public interface CheckTrait {
  public boolean test(Animal a);
}
```

```java
public class FindMatchingAnimals {
  private static void print(Animal animal, CheckTrait trait) {
    if(trait.test(animal))
      System.out.println(animal);
  }

  public static void main(String[] args) {
    print(new Animal("fish", false, true), a -> a.canHop());
    print(new Animal("kangaroo", true, false), a -> a.canHop());
  }
}
```

This expression means that Java should call a method with an Animal parameter that returns a boolean value that’s the result of a.canHop(). We know all this because we wrote the code. But how does Java know?

Java relies on context when figuring out what lambda expressions mean. We are passing this lambda as the second parameter of the print() method. That method expects a CheckTrait as the second parameter. Since we are passing a lambda instead, Java treats CheckTrait as a functional interface and tries to map it to the single
abstract method:

```java
boolean test(Animal a);
```

Since this interface’s method takes an Animal, it means the lambda parameter has to be an Animal. And since that interface’s method returns a boolean, we know that the lambda returns a boolean.

Recall that lambda expressions rely on the notion of deferred execution. Deferred execution means that code is specified now but runs later. In this case, later is when the print() method calls it. Even though the execution is deferred, the compiler will still validate that the code syntax is properly formed.