- Our programs wouldn’t be able to do anything useful if we didn’t have the ability to create new objects. Remember that an object is an instance of a class.

- To create an instance of a class, all you have to do is write new before it. For example:
```
Random r = new Random();
```

- First you declare the type that you’ll be creating (Random) and give the variable a name (r). This gives Java a place to store a reference to the object. Then you write new Random() to actually create the object.

- There are two key points to note about the constructor: The name of the constructor matches the name of the class, and there’s no return type. You’ll likely see a method like this on the exam:
```
public class Chick {
  public void Chick() { // NOT A CONSTRUCTOR
    System.out.println("in constructor");
  }
}
```

- When you see a method name beginning with a capital letter and having a return type, pay special attention to it. It is not a constructor since there’s a return type. It’s a regular method that won’t be called when you write new Chick().

- The purpose of a constructor is to initialize fields, although you can put any code in there. Another way to initialize fields is to do so directly on the line on which they’re declared. This example shows both approaches:

- It’s possible to read and write instance variables directly from the caller. In this example, a mother swan lays eggs:
```
public class Swan {
  int numberEggs;// instance variable
  public static void main(String[] args) {
    Swan mother = new Swan();
    mother.numberEggs = 1; // set variable
    System.out.println(mother.numberEggs); // read variable
  }
}
```

- You can even read and write fields directly on the line declaring them:
```
1: public class Name {
2:   String first = "Theodore";
3:   String last = "Moose";
4:   String full = first + last;
5: {
```

- When you learned about methods, you saw braces ({}). The code between the braces is called a code block. Sometimes this code is called being inside the braces. Anywhere you see braces is a code block.

- Sometimes code blocks are inside a method. These are run when the method is called. Other times, code blocks appear outside a method. These are called instance initializers.

- When writing code that initializes fields in multiple places, you have to keep track of the order of initialization. 
   - Fields and instance initializer blocks are run in the order in which they appear in the file.
   - The constructor runs after all fields and instance initializer blocks have run.

- Order matters for the fields and blocks of code. You can’t refer to a variable before it has been initialized:
```
{ System.out.println(name); } // DOES NOT COMPILE
private String name = "Fluffy";
```

- Java applications contain two types of data: primitive types and reference types.

- Java has eight built-in data types, referred to as the Java *primitive types*. These eight data types represent the building blocks for Java objects, because all Java objects are just a complex collection of these primitive data types. The exam assumes you are well versed in the eight primitive data types, their relative sizes, and what can be stored in them.

| Keyword | Type                        | Example             |
|---------|-----------------------------|---------------------|
| boolean | true or false               | true                |
| byte    | 8-bit integral value        | 123                 |
| short   | 16-bit integral value       | 123                 |
| int     | 32-bit integral value       | 123                 |
| long    | 64-bit integral value       | 123                 |
| float   | 32-bit floating-point value | 123.45f             |
| double  | 64-bit floating-point value | 123.456             |
| char    | 16-bit Unicode value        | 'a'                 |

- There’s a lot of information in Table 1.1. Let’s look at some key points:
   - float and double are used for floating-point (decimal) values.
   - A float requires the letter f following the number so Java knows it is a float.
   - byte, short, int, and long are used for numbers without decimal points.
   - Each numeric type uses twice as many bits as the smaller similar type. For example, short uses twice as many bits as byte does.
- You won’t be asked about the exact sizes of most of these types. You should know that a byte can hold a value from –128 to 127. So you aren’t stuck memorizing this, let’s look at how Java gets that. A byte is 8 bits. A bit has two possible values. (These are basic computer science definitions that you should memorize.) 2^8 is 2 × 2 = 4 × 2 = 8 × 2 = 16 × 2 = 32 × 2 = 64 × 2 = 128 × 2 = 256. Since 0 needs to be included in the range, Java takes it away from the positive side. Or if you don’t like math, you can just memorize it.

- The number of bits is used by Java when it figures out how much memory to reserve for your variable. For example, Java allocates 32 bits if you write this:
```
int num;
```

- *What Is the Largest int?*: You do not have to know this for the exam, but the maximum number an int can hold is 2,147,483,647. How do we know this? One way is to have Java tell us:
```
System.out.println(Integer.MAX_VALUE);
```

- The other way is with math. An int is 32 bits. 2^32 is 4,294,967,296. Divide that by 2 and you get 2,147,483,648. Then subtract 1 as we did with bytes and you get 2,147,483,647. It’s easier to just ask Java to print the value, isn’t it?

- There are a few more things you should know about numeric primitives. When a number is present in the code, it is called a literal. By default, Java assumes you are defining an int value with a literal. In this example, the number listed is bigger than what fits in an int. Remember, you aren’t expected to memorize the maximum value for an int. The exam will include it in the question if it comes up.
```
long max = 3123456789; // DOES NOT COMPILE
```

- Java complains the number is out of range. And it is—for an int. However, we don’t have an int. The solution is to add the character L to the number:
```
long max = 3123456789L; // now Java knows it is a long
```

- Alternatively, you could add a lowercase l to the number. But please use the uppercase L. The lowercase l looks like the number 1.

- Another way to specify numbers is to change the “base.” When you learned how to count, you studied the digits 0–9. This numbering system is called base 10 since there are 10 numbers. It is also known as the decimal number system. Java allows you to specify digits in several other formats:
   - octal (digits 0–7), which uses the number 0 as a prefix—for example, 017
   - hexadecimal (digits 0–9 and letters A–F), which uses the number 0 followed by x or X as a prefix—for example, 0xFF
   - binary (digits 0–1), which uses the number 0 followed by b or B as a prefix—for example, 0b10

- __Converting Back to Binary__: 
```
System.out.println(56); // 56 = 5 * 10 + 6
System.out.println(0b11); // 3 = 1 * 2 + 1
System.out.println(017); // 15 = 1 * 8 + 7
System.out.println(0x1F); // 31 = 1 * 16 + F
```

- The last thing you need to know about numeric literals is a feature added in Java 7. You can have underscores in numbers to make them easier to read:
```
int million1 = 1000000;
int million2 = 1_000_000;
```

- We’d rather be reading the latter one because the zeroes don’t run together. You can add underscores anywhere except at the beginning of a literal, the end of a literal, right before a decimal point, or right after a decimal point. Let’s look at a few examples:
```
double notAtStart = _1000.00; // DOES NOT COMPILE
double notAtEnd = 1000.00_; // DOES NOT COMPILE
double notByDecimal = 1000_.00; // DOES NOT COMPILE
double annoyingButLegal = 1_00_0.0_0; // this one compiles
```

- A *reference* type refers to an object (an instance of a class). Unlike primitive types that hold their values in the memory where the variable is allocated, references do not hold the value of the object they refer to. Instead, a reference “points” to an object by storing the memory address where the object is located, a concept referred to as a *pointer*. Unlike other languages, Java does not allow you to learn what the physical memory address is. You can only use the reference to refer to the object.

- Let’s take a look at some examples that declare and initialize reference types. Suppose we declare a reference of type java.util.Date and a reference of type String:
```
java.util.Date today;
String greeting;
```

- The `today` variable is a reference of type Date and can only point to a Date object. The `greeting` variable is a reference that can only point to a String object. A value is assigned to a reference in one of two ways:
   - A reference can be assigned to another object of the same type.
   - A reference can be assigned to a new object using the new keyword.

- For example, the following statements assign these references to new objects:
```
today = new java.util.Date();
greeting = "How are you?";
```

- The today reference now points to a new Date object in memory, and today can be used to access the various fields and methods of this Date object. Similarly, the greeting reference points to a new String object, "How are you?". The String and Date objects do not have names and can be accessed only via their corresponding reference. 

- There are a few important differences you should know between primitives and reference types. First, reference types can be assigned null, which means they do not currently refer to an object. Primitive types will give you a compiler error if you attempt to assign them null. In this example, value cannot point to null because it is of type int:
```
int value = null; // DOES NOT COMPILE
String s = null;
```

- Next, reference types can be used to call methods when they do not point to null. Primitives do not have methods declared on them. In this example, we can call a method on reference since it is of a reference type. You can tell length is a method because it has () after it. The following line is gibberish. No methods exist on len because it is an int primitive. Primitives do not have methods.
```
String reference = "hello";
int len = reference.length();
int bad = len.length(); // DOES NOT COMPILE
```

- Finally, notice that all the primitive types have lowercase type names. All classes that come with Java begin with uppercase. You should follow this convention for classes you create as well.