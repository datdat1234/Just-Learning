### Interacting with Legacy Code

Legacy code is older code. It is usually code that is in a different style than you would write if you were writing the code today. In this section, we are referring to code that was written to target Java 1.4 or lower, and therefore it does not use generics. Collections written without generics are also known as raw collections.

Remember that using generics gives us compile time safety. At least it does when all of the code involved uses generics. When some code uses generics and other code does not, it is easy to get lulled into a false sense of security.

This is the problem that generics are supposed to solve. The difference is that all of the code doesn’t use generics here. The main() method calls printDragons() with a raw type. Due to type erasure, Java doesn’t know this is a problem until runtime, when it attempts to cast a Unicorn to a Dragon. The cast is tricky because it doesn’t appear in the code. With generic types, Java writes the casts for us.

Although Java doesn’t know that there is a problem, it does know there might be a problem. Java knows that raw types are asking for trouble, and it presents a compiler warning for this case. A compiler warning is different from a compiler error in that all of the code still compiles with a compiler warning. The compiler warning is Java informing you that you should take a closer look at something.

__Compiler warnings__: When compiling the LegacyDragon class, the compiler warnings look something like this:

```cmd
$ javac *.java
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
```

Java is basically telling you that it knows you are using old code and asking if you want to know more. If you pass that flag, you get something like the following. (The exact messages will depend on your compiler. For example, on some compilers, you’ll get a fourth warning where the unicorns object is declared.). The messages look a little scary, but all Java is trying to tell you is that you should really be using generics.

```java
1: public class LegacyUnicorns {
2:  public static void main(String[] args) {
3:      java.util.List<Unicorn> unicorns = new java.util.ArrayList<>();
4:      addUnicorn(unicorns);
5:      Unicorn unicorn = unicorns.get(0); // ClassCastException
6:  }
7:  private static void addUnicorn(List unicorn) {
8:      unicorn.add(new Dragon());
9:  } }
```

The main() method correctly uses generics. The problem is that it calls a legacy method that claims to add a Unicorn to the list. But this method does not actually work as advertised and adds a Dragon on line 8 instead. Then when line 5 tries to put that Dragon in a Unicorn reference, a ClassCastException occurs. Of course, this code has compiler warnings in it as well. This problem is fairly straightforward. If the legacy code doesn’t use the right types, the generics code will still fail at runtime. 

```java
1: public class LegacyAutoboxing {
2:  public static void main(String[] args) {
3:      java.util.List numbers = new java.util.ArrayList();
4:      numbers.add(5);
5:      int result = numbers.get(0); // DOES NOT COMPILE
6:  }
7: }
```

The good news is that unboxing fails with a compiler error rather than a runtime error. On line 3, we create a raw list. On line 4, we try to add an int to the list. This works because Java automatically autoboxes to an Integer. On line 5, we have a problem. Since we aren’t using generics, Java doesn’t know that the list contains an Integer. It just knows that we have an Object. And an Object can’t be unboxed into an int.

To review, the lesson is to be careful when you see code that doesn’t use generics. Pay special attention to looking for compiler warnings, ClassCastExceptions, and compiler errors.