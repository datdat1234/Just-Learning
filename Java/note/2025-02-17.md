# Overloading Methods

- Now that you are familiar with the rules for declaring methods, it is time to look at creating methods with the same signature in the same class. Method overloading occurs when there are different method signatures with the same name but different type parameters.

- We’ve been calling overloaded methods for a while. System.out.println and StringBuilder’s append methods provide many overloaded versions so you can pass just about anything to them without having to think about it. In both of these examples, the only change was the type of the parameter. Overloading also allows different numbers of parameters.

- Everything other than the method signature can vary for overloaded methods. This means there can be different access modifiers, specifiers (like static), return types, and exception lists.

- These are all valid overloaded methods:

```
public void fly(int numMiles) { }
public void fly(short numFeet) { }
public boolean fly() { return false; }
void fly(int numMiles, short numFeet) { }
public void fly(short numFeet, int numMiles) throws Exception { }
```

- As you can see, we can overload by changing anything in the parameter list. We can have a different type, more types, or the same types in a different order. Also notice that the access modifier and exception list are irrelevant to overloading.

```
public void fly(int numMiles) { }
public int fly(int numMiles) { } // DOES NOT COMPILE
```

- This method doesn’t compile because it only differs from the original by return type. The parameter lists are the same so they are duplicate methods as far as Java is concerned.

```
public void fly(int numMiles) { }
public static void fly(int numMiles) { } // DOES NOT COMPILE
```

- Again, the parameter list is the same. The only difference is that one is an instance method and one is a static method.

- Calling overloaded methods is easy. You just write code and Java calls the right one. For example, look at these two methods:

```
public void fly(int numMiles) {
 System.out.println("short");
}
public void fly(short numFeet) {
 System.out.println("short");
}
```

- The call fly((short) 1); prints short. It looks for matching types and calls the appropriate method. Of course, it can be more complicated than this.

## Overloading and Varargs 

```
public void fly(int[] lengths) { }
public void fly(int... lengths) { } // DOES NOT COMPILE
```

- Trick question! Remember that Java treats varargs as if they were an array. This means that the method signature is the same for both methods. Since we are not allowed to overload methods with the same parameter list, this code doesn't compile. Even though the code doesn't look the same, it compiles to the same parameter list.

- Now that we’ve just gotten through explaining that they are the same, it is time to mention how they are not the same. It shouldn’t be a surprise that you can call either method by passing an array:

```
fly(new int[] { 1, 2, 3 });
```

- However, you can only call the varargs version with stand-alone parameters:

```
fly(1, 2, 3);
```

- Obviously, this means they don't compile exactly the same. The parameter list is the same, though, and that is what you need to know with respect to overloading for the exam.

## Autoboxing

- In the previous chapter, you saw how Java will convert a primitive int to an object Integer to add it to an ArrayList through the wonders of autoboxing. This works for code you write too.

```
public void fly(Integer numMiles) { }
```

- This means calling fly(3); will call the previous method as expected. However, what happens if we have both a primitive and an integer version?

```
public void fly(int numMiles) { }
public void fly(Integer numMiles) { }
```

- Java will match the int numMiles version. Java tries to use the most specific parameter list it can find. When the primitive int version isn't present, it will autobox. However, when the primitive int version is provided, there is no reason for Java to do the extra work of autoboxing.

## Reference Types

- Given the rule about Java picking the most specific version of a method that it can, what do you think this code outputs?

```
public class ReferenceTypes {
 public void fly(String s) {
  System.out.print("string ");
 }
 public void fly(Object o) {
  System.out.print("object ");
 }
 public static void main(String[] args) {
  ReferenceTypes r = new ReferenceTypes();
  r.fly("test");
  r.fly(56);
 } }
```

- The answer is "string object". The first call is a String and finds a direct match. There's no reason to use the Object version when there is a nice String parameter list just waiting to be called. The second call looks for an int parameter list. When it doesn't find one, it autoboxes to Integer. Since it still doesn't find a match, it goes to the Object one.

## Primitives

- Primitives work in a way similar to reference variables. Java tries to find the most specific matching overloaded method. What do you think happens here?

```
public class Plane {
 public void fly(int i) {
  System.out.print("int ");
 }
 public void fly(long l) {
  System.out.print("long ");
 }
 public static void main(String[] args) {
  Plane p = new Plane();
  p.fly(123);
  p.fly(123L);
 } }
```

- The answer is int long. The first call passes an int and sees an exact match. The second call passes a long and also sees an exact match. If we comment out the overloaded method with the int parameter list, the output becomes long long. Java has no problem calling a larger primitive. However, it will not do so unless a better match is not found.

- Note that Java can only accept wider types. An int can be passed to a method taking a long parameter. Java will not automatically convert to a narrower type. If you want to pass a long to a method taking an int parameter, you have to add a cast to explicitly say narrowing is okay.

## Putting It All Together

- So far, all the rules for when an overloaded method is called should be logical. Java calls the most specific method it can. When some of the types interact, the Java rules focus on backward compatibility. In Java 1.4 and earlier, autoboxing and varargs didn’t exist. Although that was a long time ago, old code still needs to work—which means autoboxing and varargs come last when Java looks at overloaded methods. Ready for the official order? Table below lays it out for you.

| Rule                          | Example                              |
|-------------------------------|--------------------------------------|
| Exact match by type           | `public String glide(int i, int j) {}`    |
| Larger primitive type         | `public String glide(long i, long j) {}`   |
| Autoboxed type                | `public String glide(Integer i, Integer j) {}` |
| Varargs                       | `public String glide(int... nums) {}`        |

```
public class Glider2 {
 public static String glide(String s) {
  return "1";
 }
 public static String glide(String... s) {
  return "2";
 }
 public static String glide(Object o) {
  return "3";
 }
 public static String glide(String s, String t) {
  return "4";
 }
 public static void main(String[] args) {
  System.out.print(glide("a"));
  System.out.print(glide("a", "b"));
  System.out.print(glide("a", "b", "c"));
 } }
```

- It prints out 142. The first call matches the signature taking a single String because that is the most specific match. The second call matches the signature, taking two String parameters since that is an exact match. It isn’t until the third call that the varargs version is used since there are no better matches.

- As accommodating as Java is with trying to find a match, it will only do one conversion:

```
public class TooManyConversions {
 public static void play(Long l) { }
 public static void play(Long... l) { }
 public static void main(String[] args) {
  play(4); // DOES NOT COMPILE
  play(4L); // calls the Long version
 } }
```

- Here we have a problem. Java is happy to convert the int 4 to a long 4 or an Integer 4. It cannot handle converting in two steps to a long and then to a Long. If we had public static void play(Object o) { }, it would match because only one conversion would be necessary: from int to Integer. An Integer is an Object, as you’ll see in Chapter 5.