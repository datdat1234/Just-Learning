### Redeclaring private Methods

- The previous section defined the behavior if you override a public or protected method in the class. Now let’s expand our discussion to private methods. In Java, it is not possible to override a private method in a parent class since the parent method is not accessible from the child class. Just because a child class doesn’t have access to the parent method, doesn’t mean the child class can’t define its own version of the method. It just means, strictly speaking, that the new method is not an overridden version of the parent class’s method.

- Java permits you to redeclare a new method in the child class with the same or modified signature as the method in the parent class. This method in the child class is a separate and independent method, unrelated to the parent version’s method, so none of the rules for overriding methods are invoked. For example, let’s return to the Camel example we used in the previous section and show two related classes that define the same method:

```java
public class Camel {
 private String getNumberOfHumps() {
  return "Undefined";
 }
}

public class BactrianCamel extends Camel {
 private int getNumberOfHumps() {
  return 2;
 }
}
```

- This code compiles without issue. Notice that the return type differs in the child method from String to int. In this example, the method getNumberOfHumps() in the parent class is hidden, so the method in the child class is a new method and not an override of the method in the parent class. As you saw in the previous section, if the method in the parent class were public or protected, the method in the child class would not compile because it would violate two rules of overriding methods. The parent method in this example is private, so there are no such issues.

### Hiding Static Methods

- A hidden method occurs when a child class defines a static method with the same name and signature as a static method defined in a parent class. Method hiding is similar but not exactly the same as method overriding. First, the four previous rules for overriding a method must be followed when a method is hidden. In addition, a new rule is added for hiding a method, namely that the usage of the static keyword must be the same between parent and child classes. The following list summarizes the five rules for hiding a method:
   - 1. The method in the child class must have the same signature as the method in the parent class.
   - 2. The method in the child class must be at least as accessible or more accessible than the method in the parent class.
   - 3. The method in the child class may not throw a checked exception that is new or broader than the class of any exception thrown in the parent class method.
   - 4. If the method returns a value, it must be the same or a subclass of the method in the parent class, known as covariant return types.
   - 5. The method defined in the child class must be marked as static if it is marked as static in the parent class (method hiding). Likewise, the method must not be marked as static in the child class if it is not marked as static in the parent class (method overriding).

- Note that the first four are the same as the rules for overriding a method. Let’s review some examples of the new rule:

```java
public class Bear {
 public static void eat() {
  System.out.println("Bear is eating");
 }
}

public class Panda extends Bear {
 public static void eat() {
  System.out.println("Panda bear is chewing");
 }
 public static void main(String[] args) {
  Panda.eat();
 }
}
```

- In this example, the code compiles and runs without issue. The eat() method in the child class hides the eat() method in the parent class. Because they are both marked as static, this is not considered an overridden method. Let’s contrast this with examples that violate the fifth rule:

```java
public class Bear {
 public static void sneeze() {
  System.out.println("Bear is sneezing");
 }
 public void hibernate() {
  System.out.println("Bear is hibernating");
 }
}
public class Panda extends Bear {
 public void sneeze() { // DOES NOT COMPILE
  System.out.println("Panda bear sneezes quietly");
 }
 public static void hibernate() { // DOES NOT COMPILE
  System.out.println("Panda bear is going to sleep");
 }
}
```

- In this example, sneeze() is marked as static in the parent class but not in the child class. The compiler detects that you’re trying to override a method that should be hidden and generates a compiler error. In the second method, hibernate() is an instance member in the parent class but a static method in the child class. In this scenario, the compiler thinks that you’re trying to hide a method that should be overridden and also generates a compiler error.

- As you saw in the previous example, hiding static methods is fraught with pitfalls and potential problems and as a practice should be avoided. Though you might see questions on the exam that contain hidden static methods that are syntactically correct, avoid hiding static methods in your own work, since it tends to lead to confusing and difficult-to-read code. You should not reuse the name of a static method in your class if it is already used in the parent class.

### Overriding vs. Hiding Methods

- In our description of hiding of static methods, we indicated there was a distinction between overriding and hiding methods. Unlike overriding a method, in which a child method replaces the parent method in calls defined in both the parent and child, hidden methods only replace parent methods in the calls defined in the child class.

- At runtime the child version of an overridden method is always executed for an instance regardless of whether the method call is defined in a parent or child class method. In this manner, the parent method is never used unless an explicit call to the parent method is referenced, using the syntax ParentClassName.method(). Alternatively, at runtime the parent version of a hidden method is always executed if the call to the method is defined in the parent class. Let’s take a look at an example:

```java
public class Marsupial {
 public static boolean isBiped() {
  return false;
 }
 public void getMarsupialDescription() {
  System.out.println("Marsupial walks on two legs: "+isBiped());
 }
}

public class Kangaroo extends Marsupial {
 public static boolean isBiped() {
  return true;
 }
 public void getKangarooDescription() {
  System.out.println("Kangaroo hops on two legs: "+isBiped());
 }
 public static void main(String[] args) {
  Kangaroo joey = new Kangaroo();
  joey.getMarsupialDescription();
  joey.getKangarooDescription();
 }
}
```

- In this example, the code compiles and runs without issue, outputting the following:

```
Marsupial walks on two legs: false
Kangaroo hops on two legs: true
```

- Notice that isBiped() returns false in the parent class and true in the child class. In the first method call, the parent method getMarsupialDescription() is used. The Marsupial class only knows about isBiped() from its own class definition, so it outputs false. In the second method call, the child executes a method of isBiped(), which hides the parent method’s version and returns true.

- Contrast this first example with the following example, which uses an overridden version of isBiped() instead of a hidden version:

```java
class Marsupial {
 public boolean isBiped() {
  return false;
 }
 public void getMarsupialDescription() {
  System.out.println("Marsupial walks on two legs: "+isBiped());
 }
}
public class Kangaroo extends Marsupial {
 public boolean isBiped() {
  return true;
 }
 public void getKangarooDescription() {
  System.out.println("Kangaroo hops on two legs: "+isBiped());
 }
 public static void main(String[] args) {
  Kangaroo joey = new Kangaroo();
  joey.getMarsupialDescription();
  joey.getKangarooDescription();
 }
}
```

- This code also compiles and runs without issue, but it outputs slightly different text:

```
Marsupial walks on two legs: true
Kangaroo hops on two legs: true
```

- In this example, the isBiped() method is overridden, not hidden, in the child class. Therefore, it is replaced at runtime in the parent class with the call to the child class’s method.

- Make sure you understand these examples as they show how hidden and overridden methods are fundamentally different. This example makes uses of polymorphism, which we’ll discuss later in this chapter.