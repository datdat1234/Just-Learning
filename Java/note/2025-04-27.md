# Chapter 1: Advanced Class Design

## Reviewing OCA Concepts

### Access Modifiers

| Access Modifier                                             | Member in the Same Class | Member in Another Class in the Same Package | Member in a Superclass in a Different Package | Method/Field in a Class (Not a Superclass) in a Different Package |
|------------------------------------------------------------|--------------------------|---------------------------------------------|------------------------------------------------|---------------------------------------------------------------------|
| **If that member is private?**                             | yes                      | no                                          | no                                             | no                                                                  |
| **If that member has default (package private) access?**  | yes                      | yes                                         | no                                             | no                                                                  |
| **If that member is protected?**                           | yes                      | yes                                         | yes                                            | no                                                                  |
| **If that member is public?**                              | yes                      | yes                                         | yes                                            | yes                                                                 |

### Overloading and Overriding

- Overriding: Same method signature.

- Overloading: Same method signature but a different parameter list.

- NOT Overriding or Overloading: Has a different method
name. Remember that Java is case sensitive.

- The method signature is the method name and the parameter list.

- When multiple overloaded methods are present, Java looks for the closest match first. It tries to find the following:
   - Exact match by type
   - Matching a superclass type
   - Converting to a larger primitive type
   - Converting to an autoboxed type
   - Varargs

- For overriding, the overridden method has a few rules:
   - The access modifier must be the same or more accessible.
   - The return type must be the same or a more restrictive type, also known as covariant return types.
   - If any checked exceptions are thrown, only the same exceptions or subclasses of those exceptions are allowed to be thrown.

- The methods must not be static. (If they are, the method is hidden and not overridden.)

### Abstract Classes

An abstract class may contain any number of methods including zero. The methods can be abstract or concrete. Abstract methods may not appear in a class that is not abstract. The first concrete subclass of an abstract class is required to implement all abstract methods that were not implemented by a superclass.

### Static and Final

Final prevents a variable from changing or a method from being overridden. static makes a variable shared at the class level and uses the class name to refer to a method. 

static and final are allowed to be added on the class level too. Using final on a class means that it cannot be subclassed. As with methods, a class cannot be both abstract and final. In the Java core classes, String is final.

### Imports

Oracle no longer lists packages and imports in the objectives for the OCP 8 exam. They do include visibility modifiers, which means that you still need to understand packages and imports.

## Using instanceof

In a instanceof B, the expression returns true if the reference to which a points is an instance of class B, a subclass of B (directly or indirectly), or a class that implements the B interface (directly or indirectly).

All Java classes inherit from Object, which means that x instanceof Object is usually true, except for one case where it is false. If the literal null or a variable reference pointing to null is used to check instanceof, the result is false. null is not an Object.

The compiler knows that there is no possible way for a Hippo variable reference to be an Elephant, since Hippo doesn’t extend Elephant directly or indirectly.

```java
31: boolean b5 = anotherHippo instanceof Elephant; // DOES NOT COMPILE
```

The compilation check only applies when instanceof is called on a class. When checking whether an object is an instanceof an interface, Java waits until runtime to do the check. The reason is that a subclass could implement that interface and the compiler wouldn’t know it. 

```java
class MotherHippo extends Hippo implements Mother { }
```

The compiler knows an interface could be added, so the instanceof statement could be true for some subclasses, whereas there is no possible way to turn a Hippo into an Elephant.

The instanceof operator is commonly used to determine if an instance is a subclass of a particular object before applying an explicit cast. 

## Understanding Virtual Method Invocation

```java
abstract class Animal {
 public abstract void feed(); 
}

class Cow extends Animal {
 public void feed() { addHay(); }
 private void addHay() { }
}

class Bird extends Animal {
 public void feed() { addSeed(); }
 private void addSeed() { }
}

class Lion extends Animal {
 public void feed() { addMeat(); }
 private void addMeat() { }
}
```

We’ve just relied on virtual method invocation. We actually saw virtual methods on the OCA. They are just regular non‐static methods. Java looks for an overridden method rather than necessarily using the one in the class that the compiler says we have. The only thing new about virtual methods on the OCP is that Oracle now calls them virtual methods in the objectives. You can simply think of them as methods.

In the above example, we have an Animal instance, but Java didn’t call feed on the Animal class. Instead Java looked at the actual type of animal at runtime and called feed on that. Notice how this technique is called virtual method invocation. Instance variables don’t work this way. It will call the instance variables from exact class you call.

## Annotating Overridden Methods

You already know how to override a method. Java provides a way to indicate explicitly in the code that a method is being overridden. In Java, when you see code that begins with an @ symbol, it is an annotation. An annotation is extra information about the program, and it is a type of metadata. It can be used by the compiler or even at runtime.

The @Override annotation is used to express that you, the programmer, intend for this method to override one in a superclass or implement one from an interface. You don’t traditionally think of implementing an interface as overriding, but it actually is an override. It so happens that the method being overridden is an abstract one.

It is useful to have the compiler tell you that you are not actually overriding when you think that you are. The problem could be a typo. Or it could be that the superclass or interface changed without your knowledge. Either way, it is useful information to know so that you can fix the code. It is a great idea to get in the habit of using @Override in order to avoid accidentally overloading a method.

@Override is allowed only when referencing a method. Just as there is no such thing as overriding a field, the annotation cannot be used on a field either.

Much of the time, you will not see @Override used on the exam when a method is being overridden. The exam is testing whether you can recognize an overridden method. However, when you see @Override show up on the exam, you must check carefully that the method is doing one of three things:
   - Implementing a method from an interface
   - Overriding a superclass method of a class shown in the example
   - Overriding a method declared in Object, such as hashCode, equals, or toString

## Coding equals, hashCode, and toString

All classes in Java inherit from java.lang.Object, either directly or indirectly, which means that all classes inherit any methods defined in Object. Three of these methods are common for subclasses to override with a custom implementation. First, we will look at toString(). Then we will talk about equals() and hashCode(). Finally, we will discuss how equals() and hashCode() relate.

### toString

When studying for the OCA, we learned that Java automatically calls the toString() method if you try to print out an object. We also learned that some classes supply a human‐readable implementation of toString() and others do not.

```java
public static void main(String[] args) {
 System.out.println(new ArrayList()); // []
 System.out.println(new String[0]); // [Ljava.lang.String;@65cc892e
}
```

ArrayList provided an implementation of toString() that listed the contents of the ArrayList, in this case, an empty ArrayList. (If you want to be technical about it, a superclass of ArrayList implemented toString() and ArrayList inherited that one instead of the one in Object, whereas the array used the default implementation from Object).

Clearly, providing nice human‐readable output is going to make things easier for developers working with your code. They can simply print out your object and understand what it represents. Luckily, it is easy to override toString() and provide your own implementation.

__The Easy Way to Write toString() Methods__: Once you’ve written a toString() method, it starts to get boring to write more—especially if you want to include a lot of instance variables. Luckily, there is an open source library that takes care of it for you. Apache Commons Lang (http://commons.apache.org/proper/commons-lang/) provides some methods that you might wish were in core Java.

This is all you have to write to have Apache Commons return all of the instance variables in a String:

```java
public String toString() {
 return ToStringBuilder.reflectionToString(this);
}
```

Calling a Hippo class with this toString() method outputs something like toString.Hippo@12da89a7[name=Harry,weight=3100.0]. You might be wondering what this reflection thing is that is mentioned in the method name. Reflection is a technique used in Java to look at information about the class at runtime. This lets the ToStringBuilder class determine what are all of the instance variables and to construct a String with each.

When testing your code, there is a benefit to not having information in toString() that isn’t useful to your caller (12da89a7). Apache Commons accounts for this as well. You can write:

```java
@Override public String toString() {
 return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);
}
```

This time our Hippo test class outputs Hippo[name=Harry,weight=3100.0]. There are a few other styles that support letting you choose to omit the class names or the instance variable names.