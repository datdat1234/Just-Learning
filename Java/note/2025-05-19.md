# Chapter 2: Design Patterns and Principles

What does it mean to write good code? How do you measure code and differentiate good code from bad code? Although your previous study may have focused on learning how to develop Java code that compiles and executes properly at runtime, this chapter assumes that you already know how to do that. The primary goal of this chapter is to teach you best practices for designing Java classes and writing applications that lead to code that is easier to understand, more maintainable, and that you and other developers can leverage in future projects.
Adhering to the design principles and design patterns enables you to create complex class models that smoothly interact with other developers’ applications. The better your software application is designed, the better it may adapt to changes in requirements, allowing it to scale naturally over the course of the project lifespan. Many of the Java libraries that you rely on to build your own applications may have started as simple projects that someone built to solve a commonly reoccurring problem.
To put it another way, this chapter is about teaching you powerful techniques for writing software so that you can build complex applications while avoiding the mistakes and pitfalls that previous developers have encountered.

## Designing an Interface

As you may recall, an interface is an abstract data type, similar to a class that defines a list of public abstract methods that any class implementing the interface must provide. An interface may also include constant public static final variables, default methods, and
static methods. 

An interface may extend another interface, and in doing so it inherits all of the abstract methods.

Remember that an interface cannot extend a class, nor can a class extend an interface.

Interfaces also serve to provide limited support for multiple inheritance within the Java language, as a class may implement multiple interfaces.

You can also construct interfaces that have neither methods nor class members, traditionally referred to as marker interfaces. In Chapter 8, “IO,” you will see that the java.io.Serializable interface, which contains no methods, is an example of a marker interface.

There are numerous rules associated with implementing interfaces that you should know quite well at this point. For example, interfaces cannot extend classes, nor can classes extend interfaces. Interfaces may also not be marked final or instantiated directly. There are additional rules for default methods, such as Java failing to compile if a class or interface inherits two default methods with the same signature and doesn’t provide its own implementation.