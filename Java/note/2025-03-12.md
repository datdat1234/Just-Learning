## Inheriting Methods

- Inheriting a class grants us access to the public and protected members of the parent class, but also sets the stage for collisions between methods defined in both the parent class and the subclass. In this section, we’ll review the rules for method inheritance and how Java handles such scenarios.

### Overriding a Method

- What if there is a method defined in both the parent and child class? For example, you may want to define a new version of an existing method in a child class that makes use of the definition in the parent class. In this case, you can override a method a method by declaring a new method with the signature and return type as the method in the parent class. As you may recall from Chapter 4, the method signature includes the name and list of input parameters.

- When you override a method, you may reference the parent version of the method using the super keyword. In this manner, the keywords this and super allow you to select between the current and parent version of a method, respectively. We illustrate this with the following example:

```java
public class Canine {
 public double getAverageWeight() {
  return 50;
 }
}
public class Wolf extends Canine {
 public double getAverageWeight() {
  return super.getAverageWeight()+20;
 }
 public static void main(String[] args) {
  System.out.println(new Canine().getAverageWeight());
  System.out.println(new Wolf().getAverageWeight());
 }
}
```

- In this example, in which the child class Wolf overrides the parent class Canine, the method getAverageWeight() runs without issue and outputs the following:

```
50.00
70.00
```

- You might be wondering, was the use of super in the child’s method required? For example, what would the following code output if we removed the super keyword in the getAverageWeight() method of the Wolf class?

```java
public double getAverageWeight() {
 return getAverageWeight()+20; // INFINITE LOOP
}
```

- In this example, the compiler would not call the parent Canine method; it would call the current Wolf method since it would think you were executing a recursive call. A recursive function is one that calls itself as part of execution, and it is common in programming. A recursive function must have a termination condition. In this example, there is no termination condition; therefore, the application will attempt to call itself infinitely and produce a stack overflow error at runtime.

- Overriding a method is not without limitations, though. The compiler performs the following checks when you override a nonprivate method:
   - The method in the child class must have the same signature as the method in the parent class.
   - The method in the child class must be at least as accessible or more accessible than the method in the parent class.
   - The method in the child class may not throw a checked exception that is new or broader than the class of any exception thrown in the parent class method.
   - If the method returns a value, it must be the same or a subclass of the method in the parent class, known as covariant return types.

- The first rule of overriding a method is somewhat self-explanatory. If two methods have the same name but different signatures, the methods are overloaded, not overridden. As you may recall from our discussion of overloaded methods in Chapter 4, the methods are unrelated to each other and do not share any properties.

- __Overloading vs. Overriding__: Overloading a method and overriding a method are similar in that they both involve redefining a method using the same name. They differ in that an overloaded method will use a different signature than an overridden method. This distinction allows overloaded methods a great deal more freedom in syntax than an overridden method would have. For example, take a look at the following code sample:

```java
public class Bird {
 public void fly() {
  System.out.println("Bird is flying");
 }
 public void eat(int food) {
  System.out.println("Bird is eating "+food+" units of food");
 }
}
public class Eagle extends Bird {
 public int fly(int height) {
  System.out.println("Bird is flying at "+height+" meters");
  return height;
 }
 public int eat(int food) { // DOES NOT COMPILE
  System.out.println("Bird is eating "+food+" units of food");
  return food;
 }
}
```

- The first method, fly(), is overloaded in the subclass Eagle, since the signature changes from a no-argument constructor to a constructor with one int argument. Because the method is being overloaded and not overridden, the return type can be changed from void to int without issue.

- The second method, eat(), is overridden in the subclass Eagle, since the signature is the same as it is in the parent class Bird—they both take a single argument int. Because the method is being overridden, the return type of the method in Eagle must be a subclass of the return type of the method in Bird. In this example, the return type void is not a subclass of int; therefore, the compiler will throw an exception on this method definition.

- Any time you see a method on the exam with the same name as a method in the parent class, determine whether the method is being overloaded or overridden first; doing so will help you with questions about whether the code will compile.

- Let’s review some examples of the last three rules of overriding methods so you can learn to spot the issues when they arise:

```java
public class Camel {
 protected String getNumberOfHumps() {
  return "Undefined";
 }
}
public class BactrianCamel extends Camel {
 private int getNumberOfHumps() { // DOES NOT COMPILE
  return 2;
 }
}
```

- In this example, the method in the child class doesn’t compile for two reasons. First, it violates the second rule of overriding methods: the child method must be at least as accessible as the parent. In the example, the parent method uses the protected modifier, but the child method uses the private modifier, making it less accessible in the child method than in the parent method. It also violates the fourth rule of overriding methods: the return type of the parent method and child method must be covariant. In this example, the return type of the parent method is String, whereas the return type of the child method is int, neither of which is covariant with each other.

- Any time you see a method that appears to be overridden on the example, first check to make sure it is truly being overridden and not overloaded. Once you have confirmed it is being overridden, check that the access modifiers, return types, and any exceptions defined in the method are compatible with one another. Let’s take a look at some example methods that use exceptions:

```java
public class InsufficientDataException extends Exception {}
public class Reptile {
 protected boolean hasLegs() throws InsufficientDataException {
  throw new InsufficientDataException();
 }
 protected double getWeight() throws Exception {
  return 2;
 }
}
public class Snake extends Reptile {
 protected boolean hasLegs() {
  return false;
 }
 protected double getWeight() throws InsufficientDataException{
  return 2;
 }
}
```

- n this example, both parent and child classes define two methods, hasLegs() and getWeight(). The first method, hasLegs(), throws an exception InsufficientDataException in the parent class but doesn’t throw an exception in the child class. This does not violate the third rule of overriding methods, though, as no new exception is defined. In other words, a child method may hide or eliminate a parent method’s exception without issue.

- The second method, getWeight(), throws Exception in the parent class
and InsufficientDataException in the child class. This is also permitted, as InsufficientDataException is a subclass of Exception by construction.

- Neither of the methods in the previous example violates the third rule of overriding methods, so the code compiles and runs without issue. Let’s review some examples that do violate the third rule of overriding methods:

```java
public class InsufficientDataException extends Exception {}

public class Reptile {
 protected double getHeight() throws InsufficientDataException {
  return 2;
 }
 protected int getLength() {
  return 10;
 }
}

public class Snake extends Reptile {
 protected double getHeight() throws Exception { // DOES NOT COMPILE
  return 2;
 }
 protected int getLength() throws InsufficientDataException { // DOES NOT COMPILE
  return 10;
 }
}
```

- Unlike the earlier example, neither of the methods in the child class of this code will compile. The getHeight() method in the parent class throws an InsufficientDataException, whereas the method in the child class throws an Exception. Since Exception is not a subclass of InsufficientDataException, the third rule of overriding methods is violated and the code will not compile. Coincidentally, Exception is a superclass of InsufficientDataException.

- Next, the getLength() method doesn’t throw an exception in the parent class, but it does throw an exception, InsufficientDataException, in the child class. In this manner, the child class defines a new exception that the parent class did not, which is a violation of the third rule of overriding methods.

- The last three rules of overriding a method may seem arbitrary or confusing at first, but as you’ll see later in this chapter when we discuss polymorphism, they are needed for consistency of the language. Without these rules in place, it is possible to create contradictions within the Java language.