## Creating Nested Classes

A nested class is a class that is defined within another class. A nested class that is not static is called an inner class. There are four of types of nested classes:
  - A member inner class is a class defined at the same level as instance variables. It is not static. Often, this is just referred to as an inner class without explicitly saying the type.
  - A local inner class is defined within a method.
  - An anonymous inner class is a special case of a local inner class that does not have a name.
  - A static nested class is a static class that is defined at the same level as static variables.

There are a few benefits of using inner classes. They can encapsulate helper classes by restricting them to the containing class. They can make it easy to create a class that will be used in only one place. They can make the code easier to read. They can also make the code harder to read when used improperly. 

### Member Inner Classes

A member inner class is defined at the member level of a class (the same level as the methods, instance variables, and constructors). Member inner classes have the following properties:
  - Can be declared public, private, or protected or use default access
  - Can extend any class and implement interfaces
  - Can be abstract or final
  - Cannot declare static fields or methods
  - Can access members of the outer class including private members

__.class Files for Inner Classes__: Compiling the Outer.java class with which we have been working creates two class files. Outer.class you should be expecting. For the inner class, the compiler creates Outer$Inner.class. You don’t need to know this syntax for the exam. We mention it so that you aren’t surprised to see files with $ appearing in your directories. You do need to understand that multiple class files are created.

Inner classes can have the same variable names as outer classes. There is a special way of calling this to say which class you want to access. You also aren’t limited to just one inner class. Please never do this in code you write. 

__Private Interfaces__: This following code looks weird but is legal:

```java
public class CaseOfThePrivateInterface {
  private interface Secret {
    public void shh();
  }
  class DontTell implements Secret {
    public void shh() { }
  } 
}
```

The rule that all methods in an interface are public still applies. A class that implements the interface must define that method as public.

The interface itself does not have to be public, though. Just like any inner class, an inner interface can be private. This means that the interface can only be referred to within the current outer class.

### Local Inner Classes

A local inner class is a nested class defined within a method. Like local variables, a local inner class declaration does not exist until the method is invoked, and it goes out of scope when the method returns. This means that you can create instances only from within the method. Those instances can still be returned from the method. This is just how local variables work. Local inner classes have the following properties:
  - They do not have an access specifier.
  - They cannot be declared static and cannot declare static fields or methods.
  - They have access to all fields and methods of the enclosing class.
  - They do not have access to local variables of a method unless those variables are final or effectively final. More on this shortly.

Earlier, we made the statement that local variable references are allowed if they are final or effectively final. Let’s talk about that now. The compiler is generating a class file from your inner class. A separate class has no way to refer to local variables. If the local variable is final, Java can handle it by passing it to the constructor of the inner class or by storing it in the class file. If it weren’t effectively final, these tricks wouldn’t work because the value could change after the copy was made. Up until Java 7, the programmer actually had to type the final keyword. In Java 8, the “effectively final” concept was introduced. If the code could still compile without the keyword final inserted before the local variable, the variable is effectively final.

### Anonymous Inner Classes

An anonymous inner class is a local inner class that does not have a name. It is declared and instantiated all in one statement using the new keyword. Anonymous inner classes are required to extend an existing class or implement an existing interface. They are useful when you have a short implementation that will not be used anywhere else.

```java
1: public class AnonInner {
2:   abstract class SaleTodayOnly {
3:     abstract int dollarsOff();
4:   }
5:   public int admission(int basePrice) {
6:     SaleTodayOnly sale = new SaleTodayOnly() {
7:       int dollarsOff() { return 3; }
8:     };
9:     return basePrice - sale.dollarsOff();
10:   } 
11: }
```

Lines 2 through 4 define an abstract class. Lines 6 through 8 define the inner class. Notice how this inner class does not have a name. The code says to instantiate a new SaleTodayOnly object. But wait. SaleTodayOnly is abstract. This is OK because we provide the class body right there—anonymously.

```java
1: public class AnonInner {
2:   interface SaleTodayOnly {
3:     int dollarsOff();
4:   }
5:   public int admission(int basePrice) {
6:     SaleTodayOnly sale = new SaleTodayOnly() {
7:       public int dollarsOff() { return 3; }
8:     };
9:     return basePrice - sale.dollarsOff();
10:   }
11: }
```

The most interesting thing here is how little has changed. Lines 2 through 4 declare an interface instead of an abstract class. Line 7 is public instead of using default access since interfaces require public methods. And that is it. The anonymous inner class is the same whether you implement an interface or extend a class! Java figures out which one you want automatically.

But what if we want to implement both an interface and extend a class? You can’t with an anonymous inner class, unless the class to extend is java.lang.Object. Object is a special class, so it doesn’t count in the rule. Remember that an anonymous inner class is just an unnamed local inner class. You can write a local inner class and give it a name if you have this problem. Then you can extend a class and implement as many interfaces as you like. If your code is this complex, a local inner class probably isn’t the most readable option anyway.

There is one more thing that you can do with anonymous inner classes. You can define them right where they are needed, even if that is an argument to another method.

__Inner Classes as Event Handlers__: Writing graphical user interface code isn’t on the exam. Nonetheless, it is a very common use of inner classes, so we’ll give you a taste of it here:

```java
JButton button = new JButton("red");
button.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent e) {
    // handle the button click
  }
});
```

This technique gives the event handler access to the instance variables in the class with which it goes. It works well for simple event handling.

You should be aware that inner classes go against some fundamental concepts, such as reuse of classes and high cohesion (discussed in the next chapter). Therefore, make sure that inner classes make sense before you use them in your code.

### Static Nested Classes

The final type of nested class is not an inner class. A static nested class is a static class defined at the member level. It can be instantiated without an object of the enclosing class, so it can’t access the instance variables without an explicit object of the enclosing class. For example, new OuterClass().var allows access to the instance variable var.

In other words, it is like a regular class except for the following:
  - The nesting creates a namespace because the enclosing class name must be used to refer to it.
  - It can be made private or use one of the other access modifiers to encapsulate it.
  - The enclosing class can refer to the fields and methods of the static nested class.

__Importing a static Nested Class__: Importing a static nested class is interesting. You can import it using a regular import:

```java
package bird;
public class Toucan {
  public static class Beak {}
}
package watcher;
import bird.Toucan.Beak; // regular import ok
public class BirdWatcher {
  Beak beak;
}
```

And since it is static, alternatively you can use a static import:

```java
import static bird.Toucan.Beak;
```

Either one will compile. Surprising, isn’t it? Java treats the static nested class as if it were a namespace.

|                          | Member Inner Class | Local Inner Class | Anonymous Inner Class | Static Nested Class |
|---------------------------------|-------------|-------------------|-----------------------|---------------------|
| **Access Modifiers Allowed**    | Public, Protected, Private, or Default | None. Already local to method. | None. Already local to statement. | Public, Protected, Private, or Default |
| **Can Extend**                  | Yes         | Yes               | No—must have exactly one superclass or one interface | Yes                 |
| **Can Be Abstract**             | Yes         | Yes               | N/A—because no class definition | Yes                 |
| **Can Be Final**                | Yes         | Yes               | N/A—because no class definition | Yes                 |
| **Can Access Instance Members of Enclosing Class** | Yes         | Yes               | Yes                   | No (not directly; requires an instance of the enclosing class) |
| **Can Access Local Variables of Enclosing Class** | No          | Yes—if final or effectively final | Yes—if final or effectively final | No                  |
| **Can Declare Static Methods**  | No          | No                | No                    | Yes                 |