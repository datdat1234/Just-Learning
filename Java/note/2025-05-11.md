### hashCode

Whenever you override equals(), you are also expected to override hashCode(). The hash code is used when storing the object as a key in a map.

A hash code is a number that puts instances of a class into a finite number of categories. Imagine that I gave you a deck of cards, and I told you that I was going to ask you for specific cards and I want to get the right card back quickly. You have as long as you want to prepare, but I’m in a big hurry when I start asking for cards. You might make 13 piles of cards: All of the aces in one pile, all the twos in another pile, and so forth. That way, when I ask for the five of hearts, you can just pull the right card out of the four cards in the pile with fives. It is certainly faster than going through the whole deck of 52 cards! You could even make 52 piles if you had enough space on the table.

What do you do if you have a primitive and need the hash code? The hash code is just a number. On the exam, you can just use a primitive number as is or divide to get a smaller int. Remember that all of the instance variables don’t need to be used in a hashCode() method. It is common not to include boolean and char variables in the hash code.

The official JavaDoc contract for hashCode() is harder to read than it needs to be. The three points in the contract boil down to these:
   - Within the same program, the result of hashCode() must not change. This means that you shouldn’t include variables that change in figuring out the hash code. In our hippo example, including the name is fine. Including the weight is not because hippos change weight regularly.
   - If equals() returns true when called with two objects, calling hashCode() on each of those objects must return the same result. This means hashCode() can use a subset of the variables that equals() uses. You saw this in the card example. We used only one of the variables to determine the hash code.
   - If equals() returns false when called with two objects, calling hashCode() on each of those objects does not have to return a different result. This means hashCode() results do not need to be unique when called on unequal objects.

__The easy way to write hashCode() methods__: You probably thought that this was going to be about the Apache Commons Lang class for hash code. There is one, but it isn’t the easiest way to write hash code. It is easier to code your own. Just pick the key fields that identify your object (and don’t change during the program) and combine them:

```java
public int hashCode() {
 return keyField + 7 * otherKeyField.hashCode();
}
```

It is common to multiply by a prime number when combining multiple fields in the hash code. This makes the hash code more unique, which helps when distributing objects into buckets.

# Working with Enums

In programming, it is common to have a type that can only have a finite set of values. An enumeration is like a fixed set of constants. In Java, an enum is a class that represents an enumeration. It is much better than a bunch of constants because it provides type‐safe checking. With numeric constants, you can pass an invalid value and not find out until runtime. With enums, it is impossible to create an invalid enum type without introducing a compiler error.

Enumerations show up whenever you have a set of items whose types are known at compile time. Common examples are the days of the week, months of the year, the planets in the solar system, or the cards in a deck. Well, maybe not the planets in a solar system, given that Pluto had its planetary status revoked.

To create an enum, use the enum keyword instead of the class keyword. Then list all of the valid types for that enum.

```java
public enum Season {
 WINTER, SPRING, SUMMER, FALL
}
```

Since an enum is like a set of constants, use the uppercase letter convention that you used for constants. Behind the scenes, an enum is a type of class that mainly contains static members. It also includes some helper methods like name() that you will see shortly. Using an enum is easy:

```java
Season s = Season.SUMMER;
System.out.println(Season.SUMMER); // SUMMER
System.out.println(s == Season.SUMMER); // true
```

As you can see, enums print the name of the enum when toString() is called. They are also comparable using == because they are like static final constants.

An enum provides a method to get an array of all of the values. You can use this like any normal array, including in a loop:

```java
for(Season season: Season.values()) {
 System.out.println(season.name() + " " + season.ordinal());
}
```

The output shows that each enum value has a corresponding int value in the order in which they are declared. The int value will remain the same during your program, but the program is easier to read if you stick to the human‐readable enum value.

```java
WINTER 0
SPRING 1
SUMMER 2
FALL 3
```

You can’t compare an int and enum value directly anyway. Remember that an enum is a type and not an int.

```java
if ( Season.SUMMER == 2) {} // DOES NOT COMPILE
```

You can also create an enum from a String. This is helpful when working with older code. The String passed in must match exactly, though.

```java
Season s1 = Season.valueOf("SUMMER"); // SUMMER
Season s2 = Season.valueOf("summer"); // exception
```

Another thing that you can’t do is extend an enum.

```java
public enum ExtendedSeason extends Season { } // DOES NOT COMPILE
```

The values in an enum are all that are allowed. You cannot add more at runtime by extending the enum.