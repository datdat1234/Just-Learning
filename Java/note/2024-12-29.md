- One of the reasons for using packages is so that class names don’t have to be unique across all of Java. This means you’ll sometimes want to import a class that can be found in multiple places. A common example of this is the Date class. Java provides implementations of java.util.Date and java.sql.Date.

- When the class is found in multiple packages, Java gives you the compiler error: *The type Date is ambiguous*
```
1. import java.util.*;
2. import java.sql.*; // DOES NOT COMPILE
```

- If you explicitly import a class name, it takes precedence over any wildcards present. Java thinks, “Okay! The programmer really wants me to assume use of the java.util.Date class.”
```
1. import java.util.Date;
2. import java.sql.*;
```

- Java is smart enough to detect that this code is no good. As a programmer, you’ve claimed to explicitly want the default to be both the java.util.Date and java.sql.Date implementations. Because there can’t be two defaults, the compiler tells you: *The import java.sql.Date collides with another import statement*
```
1. import java.util.Date;
2. import java.sql.Date;
```

- If You Really Need to Use Two Classes with the Same Name... Sometimes you really do want to use Date from two different packages. When this happens, you can pick one to use in the import and use the other’s fully qualified class name (the package name, a dot, and the class name) to specify that it’s special. Or you could have neither with an import and always use the fully qualified class name:
```
1. import java.util.Date;
public class Conflicts {
  Date date;
  java.sql.Date sqlDate;
}

2. public class Conflicts {
  java.util.Date date;
  java.sql.Date sqlDate;
}
```

- Up to now, all the code we’ve written in this chapter has been in the default package. This is a special unnamed package that you should use only for throwaway code. You can tell the code is in the default package, because there’s no package name. In real life, always name your packages to avoid naming conflicts and to allow others to reuse your code.

- The directory structure on your computer is related to the package name. Suppose we have these two classes:
```
C:\temp\packagea\ClassA.java
package packagea;
public class ClassA {
}

C:\temp\packageb\ClassB.java
package packageb;
import packagea.ClassA;
public class ClassB {
   public static void main(String[] args) {
      ClassA a;
      System.out.println("Got it");
   }
}
```

- When you run a Java program, Java knows where to look for those package names. In this case, running from C:\temp works because both packagea and packageb are underneath it.

- Class Paths and JARs: You can also specify the location of the other files explicitly using a class path. This technique is useful when the class files are located elsewhere or in special JAR files. A JAR file is like a zip file of mainly Java class files. This goes beyond what you’ll need to do on version 8 of the exam, although it appears on older versions.
```
java -cp ".:/tmp/someOtherLocation:/tmp/myJar.jar" myPackage.MyClass
```

- The dot indicates you want to include the current directory in the class path. The rest of the command says to look for loose class files (or packages) in someOtherLocation and within myJar.jar. Windows uses semicolons to separate parts of the class path; other operating systems use colons.

- Finally, you can use a wildcard (*) to match all the JARs in a directory. Here’s an example:
```
java -cp "C:\temp\directoryWithJars\*" myPackage.MyClass
```

- This command will add all the JARs to the class path that are in directoryWithJars. It won’t include any JARs in the class path that are in a subdirectory of directoryWithJars.