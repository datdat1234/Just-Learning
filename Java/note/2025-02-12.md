# Calling a Static Variable or Method

- Usually, accessing a static member is easy. You just put the classname before the method or variable and you are done. For example:

```
System.out.println(Koala.count);
Koala.main(new String[0]);
```

- There is one rule that is trickier. You can use an instance of the object to call a static method. The compiler checks for the type of the reference and uses that instead of the object—which is sneaky of Java. This code is perfectly legal:

```
5: Koala k = new Koala();
6: System.out.println(k.count); // k is a Koala
7: k = null;
8: System.out.println(k.count); // k is still a Koala
```

- Believe it or not, this code outputs 0 twice. Line 6 sees that k is a Koala and count is a static variable, so it reads that static variable. Line 8 does the same thing. Java doesn’t care that k happens to be null. Since we are looking for a static, it doesn’t matter.


- Remember to look at the reference type for a variable when you see a static method or variable. The exam creators will try to trick you into thinking a NullPointerException is thrown because the variable happens to be null. Don’t be fooled!

```
Koala.count = 4;
Koala koala1 = new Koala();
Koala koala2 = new Koala();
koala1.count = 6;
koala2.count = 5;
System.out.println(Koala.count);
```

- Hopefully, you answered 5. There is only one count variable since it is static. It is set to 4, then 6, and finally winds up as 5. All the Koala variables are just distractions.

# Static vs. Instance

- A static member cannot call an instance member. This shouldn’t be a surprise since static doesn’t require any instances of the class to be around. The following is a common mistake for rookie programmers to make:

```
public class Static {
 private String name = "Static class";
 public static void first() { }
 public static void second() { }
 public void third() { System.out.println(name); }
 public static void main(String args[]) {
  first();
  second();
  third(); // DOES NOT COMPILE
 } }
```

- The compiler will give you an error about making a static reference to a nonstatic method. If we fix this by adding static to third(), we create a new problem. Can you figure out what it is?

- All this does is move the problem. Now, third() is referring to nonstatic name. Adding static to name as well would solve the problem. Another solution would have been to call third as an instance method—for example, new Static().third();.

- The exam creators like this topic. A static method or instance method can call a static method because static methods don’t require an object to use. Only an instance method can call another instance method on the same class without using a reference variable, because instance methods do require an object. Similar logic applies for the instance and static variables. Make sure you understand Table below before continuing.

| Type                             | Calling? | Legal? | How?                                  |
|----------------------------------|----------|--------|---------------------------------------|
| Static method                     | Another static method or variable | Yes    | Using the classname                   |
| Static method                     | An instance method or variable    | No     |                                       |
| Instance method                   | A static method or variable       | Yes    | Using the classname or a reference variable |
| Instance method                   | Another instance method or variable | Yes    | Using a reference variable            |

```
1: public class Gorilla {
2:   public static int count;
3:   public static void addGorilla() { count++; }
4:   public void babyGorilla() { count++; }
5:   public void announceBabies() {
6:     addGorilla();
7:     babyGorilla();
8:   }
9:   public static void announceBabiesToEveryone() {
10:    addGorilla();
11:    babyGorilla(); // DOES NOT COMPILE
12:  }
13:  public int total;
14:  public static average = total / count; // DOES NOT COMPILE
15: }
```

- Lines 3 and 4 are fine because both static and instance methods can refer to a static variable. Lines 5–8 are fine because an instance method can call a static method. Line 11 doesn’t compile because a static method cannot call an instance method. Similarly, line 14 doesn’t compile because a static variable is trying to use an instance variable.

- A common use for static variables is counting the number of instances:

```
public class Counter {
 private static int count;
 public Counter() { count++; }
 public static void main(String[] args) {
  Counter c1 = new Counter();
  Counter c2 = new Counter();
  Counter c3 = new Counter();
  System.out.println(count); // 3
 }
}
```

- Each time the constructor gets called, it increments count by 1. This example relies on the fact that static (and instance) variables are automatically initialized to the default value for that type, which is 0 for int. See Chapter 1 to review the default values.

- Also notice that we didn’t write Counter.count. We could have. It isn’t necessary because we are already in that class so the compiler can infer it.

# Static Variables

- Some static variables are meant to change as the program runs. Counters are a common example of this. We want the count to increase over time. Just as with instance variables, you can initialize a static variable on the line it is declared:

```
public class Initializers {
  private static int counter = 0; // initialization
}
```

- Other static variables are meant to never change during the program. This type of variable is known as a constant. It uses the final modifier to ensure the variable never changes. static final constants use a different naming convention than other variables. They use all uppercase letters with underscores between “words.” For example:

```
public class Initializers {
 private static final int NUM_BUCKETS = 45;
 public static void main(String[] args) {
  NUM_BUCKETS = 5; // DOES NOT COMPILE
 } }
```

- The compiler will make sure that you do not accidentally try to update a final variable. This can get interesting. Do you think the following compiles?

```
private static final ArrayList<String> values = new ArrayList<>();
public static void main(String[] args) {
  values.add("changed");
}
```

- It actually does compile. values is a reference variable. We are allowed to call methods on reference variables. All the compiler can do is check that we don’t try to reassign the final values to point to a different object.