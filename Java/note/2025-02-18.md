# Creating Constructors

- A constructor is a special method that matches the name of the class and has no return type. Here’s an example:

```
public class Bunny {
 public Bunny() {
  System.out.println("constructor");
 }
}
```

- The name of the constructor, Bunny, matches the name of the class, Bunny, and there is no return type, not even void. That makes this a constructor. Can you tell why these two are not valid constructors for the Bunny class?

```
public bunny() { } // DOES NOT COMPILE
public void Bunny() { }
```

- The first one doesn't match the classname because Java is case sensitive. Since it doesn't match, Java knows it can't be a constructor and is supposed to be a regular method. However, it is missing the return type and doesn't compile. The second method is a perfectly good method, but is not a constructor because it has a return type.

- Constructors are used when creating a new object. This process is called instantiation because it creates a new instance of the class. A constructor is called when we write new followed by the name of the class we want to instantiate. For example:

```
new Bunny()
```

- When Java sees the new keyword, it allocates memory for the new object. Java also looks for a constructor and calls it.

- A constructor is typically used to initialize instance variables. The this keyword tells Java you want to reference an instance variable. Most of the time, this is optional. The problem is that sometimes there are two variables with the same name. In a constructor, one is a parameter and one is an instance variable. If you don’t say otherwise, Java gives you the one with the most granular scope, which is the parameter. Using this.name tells Java you want the instance variable.

```
1: public class Bunny {
2:  private String color;
3:  public Bunny(String color) {
4:   this.color = color;
5: } }
```

- On line 4, we assign the parameter color to the instance variable color. The right side of the assignment refers to the parameter because we don’t specify anything special. The left side of the assignment uses this to tell Java we want it to use the instance variable.

```
1: public class Bunny {
2:  private String color;
3:  private int height;
4:  private int length;
5:  public Bunny(int length, int theHeight) {
6:   length = this.length; // backwards – no good!
7:   height = theHeight; // fine because a different name
8:   this.color = "white"; // fine, but redundant
9:  }
10:  public static void main(String[] args) {
11:   Bunny b = new Bunny(1, 2);
12:   System.out.println(b.length + " " + b.height + " " + b.color);
13: } }
```

- Line 6 is incorrect and you should watch for it on the exam. The instance variable length starts out with a 0 value. That 0 is assigned to the method parameter length. The instance variable stays at 0. Line 7 is more straightforward. The parameter theHeight and instance variable height have different names. Since there is no naming collision, this is not required. Finally, line 8 shows that it is allowed to use this even when there is no duplication of variable names.

## Default Constructor

- Every class in Java has a constructor whether you code one or not. If you don’t include any constructors in the class, Java will create one for you without any parameters. This Java-created constructor is called the default constructor. Sometimes we call it the default no-arguments constructor for clarity. Here’s an example: 

```
public class Rabbit {
 public static void main(String[] args) {
  Rabbit rabbit = new Rabbit(); // Calls default constructor
 }
}
```

- In the Rabbit class, Java sees no constructor was coded and creates one. This default constructor is equivalent to typing this:

```
public Rabbit() {}
```

- The default constructor has an empty parameter list and an empty body. It is ne for you to type this in yourself. However, since it doesn't do anything, Java is happy to supply it for you and save you some typing.

- We keep saying generated. This happens during the compile step. If you look at the file with the .java extension, the constructor will still be missing. It is only in the compiled file with the.class extension that it makes an appearance.

- Remember that a default constructor is only supplied if there are no constructors present. Which of these classes do you think has a default constructor?

```
class Rabbit1 {
}
class Rabbit2 {
 public Rabbit2() { }
}
class Rabbit3 {
 public Rabbit3(boolean b) { }
}
class Rabbit4 {
 private Rabbit4() { }
}
```

- Only Rabbit1 gets a default no-argument constructor. It doesn't have a constructor coded so Java generates a default no-argument constructor. Rabbit2 and Rabbit3 both have public constructors already. Rabbit4 has a private constructor. Since these three classes have a constructor defined, the default no-argument constructor is not inserted for you.

```
1: public class RabbitsMultiply {
2:  public static void main(String[] args) {
3:   Rabbit1 r1 = new Rabbit1();
4:   Rabbit2 r2 = new Rabbit2();
5:   Rabbit3 r3 = new Rabbit3(true);
6:   Rabbit4 r4 = new Rabbit4(); // DOES NOT COMPILE
7: } }
```

- Line 3 calls the generated default no-argument constructor. Lines 4 and 5 call the user provided constructors. Line 6 does not compile. Rabbit4 made the constructor private so that other classes could not call it.

- Having a private constructor in a class tells the compiler not to provide a default no argument constructor. It also prevents other classes from instantiating the class. This is useful when a class only has static methods or the class wants to control all calls to create new instances of itself.

## Overloading Constructors

- Up to now, you’ve only seen one constructor per class. You can have multiple constructors in the same class as long as they have different method signatures. When overloading methods, the method name and parameter list needed to match. With constructors, the name is always the same since it has to be the same as the name of the class. This means constructors must have different parameters in order to be overloaded.

```
public class Hamster {
 private String color;
 private int weight;
 public Hamster(int weight) { // first constructor
  this.weight = weight;
  color = "brown";
 }
 public Hamster(int weight, String color) { // second constructor
  this.weight = weight;
  this.color = color;
 }
}
```

- One of the constructors takes a single int parameter. The other takes an int and a String. These parameter lists are different, so the constructors are successfully overloaded.

- There is a problem here, though. There is a bit of duplication. In programming, even a bit of duplication tends to turn into a lot of duplication as we keep adding “just one more thing.” What we really want is for the first constructor to call the second constructor with two parameters. You might be tempted to write this:

```
public Hamster(int weight) {
 Hamster(weight, "brown"); // DOES NOT COMPILE
}
```

- This will not work. Constructors can be called only by writing new before the name of the constructor. They are not like normal methods that you can just call. What happens if we stick new before the constructor name?

```
public Hamster(int weight) {
 new Hamster(weight, "brown"); // Compiles but does not do what we want
}
```

- This attempt does compile. It doesn't do what we want, though. When the constructor with one parameter is called, it creates an object with the default weight and color. It then constructs a different object with the desired weight and color and ignores the new object. That's not what we want. We want weight and color set on the object we are trying to instantiate in the first place.

- Java provides a solution: this—yes, the same keyword we used to refer to instance variables. When this is used as if it were a method, Java calls another constructor on the same instance of the class.

```
public Hamster(int weight) {
 this(weight, "brown");
}
```

- Success! Now Java calls the constructor that takes two parameters. weight and color get set on this instance. this() has one special rule you need to know. If you choose to call it, the this() call must be the first noncommented statement in the constructor.

```
3: public Hamster(int weight) {
4:  System.out.println("in constructor");
5:  // ready to call this
6:  this(weight, "brown"); // DOES NOT COMPILE
7: }
```

- Even though a print statement on line 4 doesn't change any variables, it is still a Java statement and is not allowed to be inserted before the call to this(). The comment on line 5 is just fine. Comments don't run Java statements and are allowed anywhere.

## Constructor Chaining

- Overloaded constructors often call each other. One common technique is to have each constructor add one parameter until getting to the constructor that does all the work. This approach is called constructor chaining. In this example, all three constructors are chained.

```
public class Mouse {
 private int numTeeth;
 private int numWhiskers;
 private int weight;
 public Mouse(int weight) {
  this(weight, 16); // calls constructor with 2 parameters
 }
 public Mouse(int weight, int numTeeth) {
  this(weight, numTeeth, 6); // calls constructor with 3 parameters
 }
 public Mouse(int weight, int numTeeth, int numWhiskers) {
  this.weight = weight;
  this.numTeeth = numTeeth;
  this.numWhiskers = numWhiskers;
 }
 public void print() {
  System.out.println(weight + " " + numTeeth + " " + numWhiskers);
 }
 public static void main(String[] args) {
  Mouse mouse = new Mouse(15);
  mouse.print();
 }
}
```

- This code prints 15 16 6. The main() method calls the constructor with one parameter. That constructor adds a second hard-coded value and calls the constructor with two parameters. That constructor adds one more hard-coded value and calls the constructor with three parameters. The three-parameter constructor assigns the instance variables.

## Final Fields

- As you saw earlier in the chapter, final instance variables must be assigned a value exactly once. We saw this happen in the line of the declaration and in an instance initializer. There is one more location this assignment can be done: in the constructor.

```
public class MouseHouse {
 private final int volume;
 private final String name = "The Mouse House";
 public MouseHouse(int length, int width, int height) {
  volume = length * width * height;
 }}
```

- The constructor is part of the initialization process, so it is allowed to assign final instance variables in it. By the time the constructor completes, all final instance variables must have been set.

## Order of Initialization

- Chapter 1 covered the order of initialization. Now that you’ve learned about static initializers, it is time to revisit that. Unfortunately, you do have to memorize this list. We’ll give you lots of practice, but you do need to know this order by heart.
   - If there is a superclass, initialize it first (we’ll cover this rule in the next chapter. For now, just say “no superclass” and go on to the next rule.)
   - Static variable declarations and static initializers in the order they appear in the file.
   - Instance variable declarations and instance initializers in the order they appear in the file.
   - The constructor.

```
1: public class InitializationOrderSimple {
2:  private String name = "Torchie";
3:  { System.out.println(name); }
4:  private static int COUNT = 0;
5:  static { System.out.println(COUNT); }
6:  static { COUNT += 10; System.out.println(COUNT); }
7:  public InitializationOrderSimple() {
8:   System.out.println("constructor");
9: } }

1: public class CallInitializationOrderSimple {
2:  public static void main(String[] args) {
3:  InitializationOrderSimple init = new InitializationOrderSimple();
4: } }
```

- The output is:

```
0
10
Torchie
constructor
```

- Let's look at why. Rule 1 doesn't apply because there is no superclass. Rule 2 says to run the static variable declarations and static initializers—in this case, lines 5 and 6, which output 0 and 10. Rule 3 says to run the instance variable declarations and instance initializers—here, lines 2 and 3, which output Torchie. Finally, rule 4 says to run the constructor—here, lines 7–9, which output constructor.

- The next example is a little harder. Keep in mind that the four rules apply only if an object is instantiated. If the class is referred to without a new call, only rules 1 and 2 apply. The other two rules relate to instances and constructors. They have to wait until there is code to instantiate the object.

```
1: public class InitializationOrder {
2:  private String name = "Torchie";
3:  { System.out.println(name); }
4:  private static int COUNT = 0;
5:  static { System.out.println(COUNT); }
6:  { COUNT++; System.out.println(COUNT); }
7:  public InitializationOrder() {
8:   System.out.println("constructor");
9:  }
10:  public static void main(String[] args) {
11:   System.out.println("read to construct");
12:   new InitializationOrder();
13:  }
14: }
```

- The output looks like this:

```
0
read to construct
Torchie
1
constructor
```

- Again, rule 1 doesn’t apply because there is no superclass. Rule 2 tells us to look at the static variables and static initializers—lines 4 and 5, in that order. Line 5 outputs 0. Now that the statics are out of the way, the main() method can run. Next, we can use rule 3 to run the instance variables and instance initializers. Here that is lines 2 and 3, which output Torchie. Finally, rule 4 says to run the constructor—in this case, lines 7–9, which output constructor.

- We are going to try one more example. This one is as hard as it gets. If you understand the output of this next one, congratulations on a job well done; if not, don’t worry. Write some programs to play with this. Try typing in the examples in this section and making minor changes to see what happens. For example, you might try commenting out part of the code. This will give you a better feel for what is going on. Then come back and reread this section to try the examples.

- The correct answer is 2 4 6 8 5. Let's walk through why that is. There is no superclass, so we jump right to rule 2—the statics. There are three static blocks: on lines 2, 5, and 7. They run in that order. The static block on line 2 calls the add() method, which prints 2. The static block on line 5 calls the add() method, which prints 4. The last static block, on line 7, calls new to instantiate the object. This means we can go on to rule 3 to look at the instance variables and instance initializers. There are two of those: on lines 6 and 8. They both call the add() method and print 6 and 8, respectively. Finally, we go on to rule 4 and call the constructor, which calls the add() method one more time and prints 5.

- This example is tricky for a few reasons. There’s a lot to keep track of. Also, the question has a lot of one-line code blocks and methods, making it harder to visualize which is a block. Luckily, questions like this are rare on the exam. If you see one, just write down what is going on as you read the code.